{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Bezier = void 0; // math-inlining.\n\nconst {\n  abs,\n  cos,\n  sin,\n  acos,\n  atan2,\n  sqrt,\n  pow\n} = Math; // cube root function yielding real roots\n\nfunction crt(v) {\n  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);\n} // trig constants\n\n\nconst pi = Math.PI,\n      tau = 2 * pi,\n      quart = pi / 2,\n      // float precision significant decimal\nepsilon = 0.000001,\n      // extremas used in bbox calculation and similar algorithms\nnMax = Number.MAX_SAFE_INTEGER || 9007199254740991,\n      nMin = Number.MIN_SAFE_INTEGER || -9007199254740991,\n      // a zero coordinate, which is surprisingly useful\nZERO = {\n  x: 0,\n  y: 0,\n  z: 0\n}; // Bezier utility functions\n\nconst utils = {\n  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))\n  Tvalues: [-0.0640568928626056260850430826247450385909, 0.0640568928626056260850430826247450385909, -0.1911188674736163091586398207570696318404, 0.1911188674736163091586398207570696318404, -0.3150426796961633743867932913198102407864, 0.3150426796961633743867932913198102407864, -0.4337935076260451384870842319133497124524, 0.4337935076260451384870842319133497124524, -0.5454214713888395356583756172183723700107, 0.5454214713888395356583756172183723700107, -0.6480936519369755692524957869107476266696, 0.6480936519369755692524957869107476266696, -0.7401241915785543642438281030999784255232, 0.7401241915785543642438281030999784255232, -0.8200019859739029219539498726697452080761, 0.8200019859739029219539498726697452080761, -0.8864155270044010342131543419821967550873, 0.8864155270044010342131543419821967550873, -0.9382745520027327585236490017087214496548, 0.9382745520027327585236490017087214496548, -0.9747285559713094981983919930081690617411, 0.9747285559713094981983919930081690617411, -0.9951872199970213601799974097007368118745, 0.9951872199970213601799974097007368118745],\n  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)\n  Cvalues: [0.1279381953467521569740561652246953718517, 0.1279381953467521569740561652246953718517, 0.1258374563468282961213753825111836887264, 0.1258374563468282961213753825111836887264, 0.121670472927803391204463153476262425607, 0.121670472927803391204463153476262425607, 0.1155056680537256013533444839067835598622, 0.1155056680537256013533444839067835598622, 0.1074442701159656347825773424466062227946, 0.1074442701159656347825773424466062227946, 0.0976186521041138882698806644642471544279, 0.0976186521041138882698806644642471544279, 0.086190161531953275917185202983742667185, 0.086190161531953275917185202983742667185, 0.0733464814110803057340336152531165181193, 0.0733464814110803057340336152531165181193, 0.0592985849154367807463677585001085845412, 0.0592985849154367807463677585001085845412, 0.0442774388174198061686027482113382288593, 0.0442774388174198061686027482113382288593, 0.0285313886289336631813078159518782864491, 0.0285313886289336631813078159518782864491, 0.0123412297999871995468056670700372915759, 0.0123412297999871995468056670700372915759],\n  arcfn: function (t, derivativeFn) {\n    const d = derivativeFn(t);\n    let l = d.x * d.x + d.y * d.y;\n\n    if (typeof d.z !== \"undefined\") {\n      l += d.z * d.z;\n    }\n\n    return sqrt(l);\n  },\n  compute: function (t, points, _3d) {\n    // shortcuts\n    if (t === 0) {\n      points[0].t = 0;\n      return points[0];\n    }\n\n    const order = points.length - 1;\n\n    if (t === 1) {\n      points[order].t = 1;\n      return points[order];\n    }\n\n    const mt = 1 - t;\n    let p = points; // constant?\n\n    if (order === 0) {\n      points[0].t = t;\n      return points[0];\n    } // linear?\n\n\n    if (order === 1) {\n      const ret = {\n        x: mt * p[0].x + t * p[1].x,\n        y: mt * p[0].y + t * p[1].y,\n        t: t\n      };\n\n      if (_3d) {\n        ret.z = mt * p[0].z + t * p[1].z;\n      }\n\n      return ret;\n    } // quadratic/cubic curve?\n\n\n    if (order < 4) {\n      let mt2 = mt * mt,\n          t2 = t * t,\n          a,\n          b,\n          c,\n          d = 0;\n\n      if (order === 2) {\n        p = [p[0], p[1], p[2], ZERO];\n        a = mt2;\n        b = mt * t * 2;\n        c = t2;\n      } else if (order === 3) {\n        a = mt2 * mt;\n        b = mt2 * t * 3;\n        c = mt * t2 * 3;\n        d = t * t2;\n      }\n\n      const ret = {\n        x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,\n        y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,\n        t: t\n      };\n\n      if (_3d) {\n        ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;\n      }\n\n      return ret;\n    } // higher order curves: use de Casteljau's computation\n\n\n    const dCpts = JSON.parse(JSON.stringify(points));\n\n    while (dCpts.length > 1) {\n      for (let i = 0; i < dCpts.length - 1; i++) {\n        dCpts[i] = {\n          x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t,\n          y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t\n        };\n\n        if (typeof dCpts[i].z !== \"undefined\") {\n          dCpts[i] = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t;\n        }\n      }\n\n      dCpts.splice(dCpts.length - 1, 1);\n    }\n\n    dCpts[0].t = t;\n    return dCpts[0];\n  },\n  computeWithRatios: function (t, points, ratios, _3d) {\n    const mt = 1 - t,\n          r = ratios,\n          p = points;\n    let f1 = r[0],\n        f2 = r[1],\n        f3 = r[2],\n        f4 = r[3],\n        d; // spec for linear\n\n    f1 *= mt;\n    f2 *= t;\n\n    if (p.length === 2) {\n      d = f1 + f2;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z) / d,\n        t: t\n      };\n    } // upgrade to quadratic\n\n\n    f1 *= mt;\n    f2 *= 2 * mt;\n    f3 *= t * t;\n\n    if (p.length === 3) {\n      d = f1 + f2 + f3;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d,\n        t: t\n      };\n    } // upgrade to cubic\n\n\n    f1 *= mt;\n    f2 *= 1.5 * mt;\n    f3 *= 3 * mt;\n    f4 *= t * t * t;\n\n    if (p.length === 4) {\n      d = f1 + f2 + f3 + f4;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d,\n        t: t\n      };\n    }\n  },\n  derive: function (points, _3d) {\n    const dpoints = [];\n\n    for (let p = points, d = p.length, c = d - 1; d > 1; d--, c--) {\n      const list = [];\n\n      for (let j = 0, dpt; j < c; j++) {\n        dpt = {\n          x: c * (p[j + 1].x - p[j].x),\n          y: c * (p[j + 1].y - p[j].y)\n        };\n\n        if (_3d) {\n          dpt.z = c * (p[j + 1].z - p[j].z);\n        }\n\n        list.push(dpt);\n      }\n\n      dpoints.push(list);\n      p = list;\n    }\n\n    return dpoints;\n  },\n  between: function (v, m, M) {\n    return m <= v && v <= M || utils.approximately(v, m) || utils.approximately(v, M);\n  },\n  approximately: function (a, b, precision) {\n    return abs(a - b) <= (precision || epsilon);\n  },\n  length: function (derivativeFn) {\n    const z = 0.5,\n          len = utils.Tvalues.length;\n    let sum = 0;\n\n    for (let i = 0, t; i < len; i++) {\n      t = z * utils.Tvalues[i] + z;\n      sum += utils.Cvalues[i] * utils.arcfn(t, derivativeFn);\n    }\n\n    return z * sum;\n  },\n  map: function (v, ds, de, ts, te) {\n    const d1 = de - ds,\n          d2 = te - ts,\n          v2 = v - ds,\n          r = v2 / d1;\n    return ts + d2 * r;\n  },\n  lerp: function (r, v1, v2) {\n    const ret = {\n      x: v1.x + r * (v2.x - v1.x),\n      y: v1.y + r * (v2.y - v1.y)\n    };\n\n    if (!!v1.z && !!v2.z) {\n      ret.z = v1.z + r * (v2.z - v1.z);\n    }\n\n    return ret;\n  },\n  pointToString: function (p) {\n    let s = p.x + \"/\" + p.y;\n\n    if (typeof p.z !== \"undefined\") {\n      s += \"/\" + p.z;\n    }\n\n    return s;\n  },\n  pointsToString: function (points) {\n    return \"[\" + points.map(utils.pointToString).join(\", \") + \"]\";\n  },\n  copy: function (obj) {\n    return JSON.parse(JSON.stringify(obj));\n  },\n  angle: function (o, v1, v2) {\n    const dx1 = v1.x - o.x,\n          dy1 = v1.y - o.y,\n          dx2 = v2.x - o.x,\n          dy2 = v2.y - o.y,\n          cross = dx1 * dy2 - dy1 * dx2,\n          dot = dx1 * dx2 + dy1 * dy2;\n    return atan2(cross, dot);\n  },\n  // round as string, to avoid rounding errors\n  round: function (v, d) {\n    const s = \"\" + v;\n    const pos = s.indexOf(\".\");\n    return parseFloat(s.substring(0, pos + 1 + d));\n  },\n  dist: function (p1, p2) {\n    const dx = p1.x - p2.x,\n          dy = p1.y - p2.y;\n    return sqrt(dx * dx + dy * dy);\n  },\n  closest: function (LUT, point) {\n    let mdist = pow(2, 63),\n        mpos,\n        d;\n    LUT.forEach(function (p, idx) {\n      d = utils.dist(point, p);\n\n      if (d < mdist) {\n        mdist = d;\n        mpos = idx;\n      }\n    });\n    return {\n      mdist: mdist,\n      mpos: mpos\n    };\n  },\n  abcratio: function (t, n) {\n    // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n\n    const bottom = pow(t, n) + pow(1 - t, n),\n          top = bottom - 1;\n    return abs(top / bottom);\n  },\n  projectionratio: function (t, n) {\n    // see u(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n\n    const top = pow(1 - t, n),\n          bottom = pow(t, n) + top;\n    return top / bottom;\n  },\n  lli8: function (x1, y1, x2, y2, x3, y3, x4, y4) {\n    const nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n          ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n          d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n\n    if (d == 0) {\n      return false;\n    }\n\n    return {\n      x: nx / d,\n      y: ny / d\n    };\n  },\n  lli4: function (p1, p2, p3, p4) {\n    const x1 = p1.x,\n          y1 = p1.y,\n          x2 = p2.x,\n          y2 = p2.y,\n          x3 = p3.x,\n          y3 = p3.y,\n          x4 = p4.x,\n          y4 = p4.y;\n    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);\n  },\n  lli: function (v1, v2) {\n    return utils.lli4(v1, v1.c, v2, v2.c);\n  },\n  makeline: function (p1, p2) {\n    const x1 = p1.x,\n          y1 = p1.y,\n          x2 = p2.x,\n          y2 = p2.y,\n          dx = (x2 - x1) / 3,\n          dy = (y2 - y1) / 3;\n    return new Bezier(x1, y1, x1 + dx, y1 + dy, x1 + 2 * dx, y1 + 2 * dy, x2, y2);\n  },\n  findbbox: function (sections) {\n    let mx = nMax,\n        my = nMax,\n        MX = nMin,\n        MY = nMin;\n    sections.forEach(function (s) {\n      const bbox = s.bbox();\n      if (mx > bbox.x.min) mx = bbox.x.min;\n      if (my > bbox.y.min) my = bbox.y.min;\n      if (MX < bbox.x.max) MX = bbox.x.max;\n      if (MY < bbox.y.max) MY = bbox.y.max;\n    });\n    return {\n      x: {\n        min: mx,\n        mid: (mx + MX) / 2,\n        max: MX,\n        size: MX - mx\n      },\n      y: {\n        min: my,\n        mid: (my + MY) / 2,\n        max: MY,\n        size: MY - my\n      }\n    };\n  },\n  shapeintersections: function (s1, bbox1, s2, bbox2, curveIntersectionThreshold) {\n    if (!utils.bboxoverlap(bbox1, bbox2)) return [];\n    const intersections = [];\n    const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];\n    const a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];\n    a1.forEach(function (l1) {\n      if (l1.virtual) return;\n      a2.forEach(function (l2) {\n        if (l2.virtual) return;\n        const iss = l1.intersects(l2, curveIntersectionThreshold);\n\n        if (iss.length > 0) {\n          iss.c1 = l1;\n          iss.c2 = l2;\n          iss.s1 = s1;\n          iss.s2 = s2;\n          intersections.push(iss);\n        }\n      });\n    });\n    return intersections;\n  },\n  makeshape: function (forward, back, curveIntersectionThreshold) {\n    const bpl = back.points.length;\n    const fpl = forward.points.length;\n    const start = utils.makeline(back.points[bpl - 1], forward.points[0]);\n    const end = utils.makeline(forward.points[fpl - 1], back.points[0]);\n    const shape = {\n      startcap: start,\n      forward: forward,\n      back: back,\n      endcap: end,\n      bbox: utils.findbbox([start, forward, back, end])\n    };\n\n    shape.intersections = function (s2) {\n      return utils.shapeintersections(shape, shape.bbox, s2, s2.bbox, curveIntersectionThreshold);\n    };\n\n    return shape;\n  },\n  getminmax: function (curve, d, list) {\n    if (!list) return {\n      min: 0,\n      max: 0\n    };\n    let min = nMax,\n        max = nMin,\n        t,\n        c;\n\n    if (list.indexOf(0) === -1) {\n      list = [0].concat(list);\n    }\n\n    if (list.indexOf(1) === -1) {\n      list.push(1);\n    }\n\n    for (let i = 0, len = list.length; i < len; i++) {\n      t = list[i];\n      c = curve.get(t);\n\n      if (c[d] < min) {\n        min = c[d];\n      }\n\n      if (c[d] > max) {\n        max = c[d];\n      }\n    }\n\n    return {\n      min: min,\n      mid: (min + max) / 2,\n      max: max,\n      size: max - min\n    };\n  },\n  align: function (points, line) {\n    const tx = line.p1.x,\n          ty = line.p1.y,\n          a = -atan2(line.p2.y - ty, line.p2.x - tx),\n          d = function (v) {\n      return {\n        x: (v.x - tx) * cos(a) - (v.y - ty) * sin(a),\n        y: (v.x - tx) * sin(a) + (v.y - ty) * cos(a)\n      };\n    };\n\n    return points.map(d);\n  },\n  roots: function (points, line) {\n    line = line || {\n      p1: {\n        x: 0,\n        y: 0\n      },\n      p2: {\n        x: 1,\n        y: 0\n      }\n    };\n    const order = points.length - 1;\n    const aligned = utils.align(points, line);\n\n    const reduce = function (t) {\n      return 0 <= t && t <= 1;\n    };\n\n    if (order === 2) {\n      const a = aligned[0].y,\n            b = aligned[1].y,\n            c = aligned[2].y,\n            d = a - 2 * b + c;\n\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n              m2 = -a + b,\n              v1 = -(m1 + m2) / d,\n              v2 = -(-m1 + m2) / d;\n        return [v1, v2].filter(reduce);\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * b - 2 * c)].filter(reduce);\n      }\n\n      return [];\n    } // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm\n\n\n    const pa = aligned[0].y,\n          pb = aligned[1].y,\n          pc = aligned[2].y,\n          pd = aligned[3].y;\n    let d = -pa + 3 * pb - 3 * pc + pd,\n        a = 3 * pa - 6 * pb + 3 * pc,\n        b = -3 * pa + 3 * pb,\n        c = pa;\n\n    if (utils.approximately(d, 0)) {\n      // this is not a cubic curve.\n      if (utils.approximately(a, 0)) {\n        // in fact, this is not a quadratic curve either.\n        if (utils.approximately(b, 0)) {\n          // in fact in fact, there are no solutions.\n          return [];\n        } // linear solution:\n\n\n        return [-c / b].filter(reduce);\n      } // quadratic solution:\n\n\n      const q = sqrt(b * b - 4 * a * c),\n            a2 = 2 * a;\n      return [(q - b) / a2, (-b - q) / a2].filter(reduce);\n    } // at this point, we know we need a cubic solution:\n\n\n    a /= d;\n    b /= d;\n    c /= d;\n    const p = (3 * b - a * a) / 3,\n          p3 = p / 3,\n          q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,\n          q2 = q / 2,\n          discriminant = q2 * q2 + p3 * p3 * p3;\n    let u1, v1, x1, x2, x3;\n\n    if (discriminant < 0) {\n      const mp3 = -p / 3,\n            mp33 = mp3 * mp3 * mp3,\n            r = sqrt(mp33),\n            t = -q / (2 * r),\n            cosphi = t < -1 ? -1 : t > 1 ? 1 : t,\n            phi = acos(cosphi),\n            crtr = crt(r),\n            t1 = 2 * crtr;\n      x1 = t1 * cos(phi / 3) - a / 3;\n      x2 = t1 * cos((phi + tau) / 3) - a / 3;\n      x3 = t1 * cos((phi + 2 * tau) / 3) - a / 3;\n      return [x1, x2, x3].filter(reduce);\n    } else if (discriminant === 0) {\n      u1 = q2 < 0 ? crt(-q2) : -crt(q2);\n      x1 = 2 * u1 - a / 3;\n      x2 = -u1 - a / 3;\n      return [x1, x2].filter(reduce);\n    } else {\n      const sd = sqrt(discriminant);\n      u1 = crt(-q2 + sd);\n      v1 = crt(q2 + sd);\n      return [u1 - v1 - a / 3].filter(reduce);\n    }\n  },\n  droots: function (p) {\n    // quadratic roots are easy\n    if (p.length === 3) {\n      const a = p[0],\n            b = p[1],\n            c = p[2],\n            d = a - 2 * b + c;\n\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n              m2 = -a + b,\n              v1 = -(m1 + m2) / d,\n              v2 = -(-m1 + m2) / d;\n        return [v1, v2];\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * (b - c))];\n      }\n\n      return [];\n    } // linear roots are even easier\n\n\n    if (p.length === 2) {\n      const a = p[0],\n            b = p[1];\n\n      if (a !== b) {\n        return [a / (a - b)];\n      }\n\n      return [];\n    }\n\n    return [];\n  },\n  curvature: function (t, d1, d2, _3d, kOnly) {\n    let num,\n        dnm,\n        adk,\n        dk,\n        k = 0,\n        r = 0; //\n    // We're using the following formula for curvature:\n    //\n    //              x'y\" - y'x\"\n    //   k(t) = ------------------\n    //           (x'² + y'²)^(3/2)\n    //\n    // from https://en.wikipedia.org/wiki/Radius_of_curvature#Definition\n    //\n    // With it corresponding 3D counterpart:\n    //\n    //          sqrt( (y'z\" - y\"z')² + (z'x\" - z\"x')² + (x'y\" - x\"y')²)\n    //   k(t) = -------------------------------------------------------\n    //                     (x'² + y'² + z'²)^(3/2)\n    //\n\n    const d = utils.compute(t, d1);\n    const dd = utils.compute(t, d2);\n    const qdsum = d.x * d.x + d.y * d.y;\n\n    if (_3d) {\n      num = sqrt(pow(d.y * dd.z - dd.y * d.z, 2) + pow(d.z * dd.x - dd.z * d.x, 2) + pow(d.x * dd.y - dd.x * d.y, 2));\n      dnm = pow(qdsum + d.z * d.z, 3 / 2);\n    } else {\n      num = d.x * dd.y - d.y * dd.x;\n      dnm = pow(qdsum, 3 / 2);\n    }\n\n    if (num === 0 || dnm === 0) {\n      return {\n        k: 0,\n        r: 0\n      };\n    }\n\n    k = num / dnm;\n    r = dnm / num; // We're also computing the derivative of kappa, because\n    // there is value in knowing the rate of change for the\n    // curvature along the curve. And we're just going to\n    // ballpark it based on an epsilon.\n\n    if (!kOnly) {\n      // compute k'(t) based on the interval before, and after it,\n      // to at least try to not introduce forward/backward pass bias.\n      const pk = utils.curvature(t - 0.001, d1, d2, _3d, true).k;\n      const nk = utils.curvature(t + 0.001, d1, d2, _3d, true).k;\n      dk = (nk - k + (k - pk)) / 2;\n      adk = (abs(nk - k) + abs(k - pk)) / 2;\n    }\n\n    return {\n      k: k,\n      r: r,\n      dk: dk,\n      adk: adk\n    };\n  },\n  inflections: function (points) {\n    if (points.length < 4) return []; // FIXME: TODO: add in inflection abstraction for quartic+ curves?\n\n    const p = utils.align(points, {\n      p1: points[0],\n      p2: points.slice(-1)[0]\n    }),\n          a = p[2].x * p[1].y,\n          b = p[3].x * p[1].y,\n          c = p[1].x * p[2].y,\n          d = p[3].x * p[2].y,\n          v1 = 18 * (-3 * a + 2 * b + 3 * c - d),\n          v2 = 18 * (3 * a - b - 3 * c),\n          v3 = 18 * (c - a);\n\n    if (utils.approximately(v1, 0)) {\n      if (!utils.approximately(v2, 0)) {\n        let t = -v3 / v2;\n        if (0 <= t && t <= 1) return [t];\n      }\n\n      return [];\n    }\n\n    const trm = v2 * v2 - 4 * v1 * v3,\n          sq = Math.sqrt(trm),\n          d2 = 2 * v1;\n    if (utils.approximately(d2, 0)) return [];\n    return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function (r) {\n      return 0 <= r && r <= 1;\n    });\n  },\n  bboxoverlap: function (b1, b2) {\n    const dims = [\"x\", \"y\"],\n          len = dims.length;\n\n    for (let i = 0, dim, l, t, d; i < len; i++) {\n      dim = dims[i];\n      l = b1[dim].mid;\n      t = b2[dim].mid;\n      d = (b1[dim].size + b2[dim].size) / 2;\n      if (abs(l - t) >= d) return false;\n    }\n\n    return true;\n  },\n  expandbox: function (bbox, _bbox) {\n    if (_bbox.x.min < bbox.x.min) {\n      bbox.x.min = _bbox.x.min;\n    }\n\n    if (_bbox.y.min < bbox.y.min) {\n      bbox.y.min = _bbox.y.min;\n    }\n\n    if (_bbox.z && _bbox.z.min < bbox.z.min) {\n      bbox.z.min = _bbox.z.min;\n    }\n\n    if (_bbox.x.max > bbox.x.max) {\n      bbox.x.max = _bbox.x.max;\n    }\n\n    if (_bbox.y.max > bbox.y.max) {\n      bbox.y.max = _bbox.y.max;\n    }\n\n    if (_bbox.z && _bbox.z.max > bbox.z.max) {\n      bbox.z.max = _bbox.z.max;\n    }\n\n    bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;\n    bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;\n\n    if (bbox.z) {\n      bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;\n    }\n\n    bbox.x.size = bbox.x.max - bbox.x.min;\n    bbox.y.size = bbox.y.max - bbox.y.min;\n\n    if (bbox.z) {\n      bbox.z.size = bbox.z.max - bbox.z.min;\n    }\n  },\n  pairiteration: function (c1, c2, curveIntersectionThreshold) {\n    const c1b = c1.bbox(),\n          c2b = c2.bbox(),\n          r = 100000,\n          threshold = curveIntersectionThreshold || 0.5;\n\n    if (c1b.x.size + c1b.y.size < threshold && c2b.x.size + c2b.y.size < threshold) {\n      return [(r * (c1._t1 + c1._t2) / 2 | 0) / r + \"/\" + (r * (c2._t1 + c2._t2) / 2 | 0) / r];\n    }\n\n    let cc1 = c1.split(0.5),\n        cc2 = c2.split(0.5),\n        pairs = [{\n      left: cc1.left,\n      right: cc2.left\n    }, {\n      left: cc1.left,\n      right: cc2.right\n    }, {\n      left: cc1.right,\n      right: cc2.right\n    }, {\n      left: cc1.right,\n      right: cc2.left\n    }];\n    pairs = pairs.filter(function (pair) {\n      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());\n    });\n    let results = [];\n    if (pairs.length === 0) return results;\n    pairs.forEach(function (pair) {\n      results = results.concat(utils.pairiteration(pair.left, pair.right, threshold));\n    });\n    results = results.filter(function (v, i) {\n      return results.indexOf(v) === i;\n    });\n    return results;\n  },\n  getccenter: function (p1, p2, p3) {\n    const dx1 = p2.x - p1.x,\n          dy1 = p2.y - p1.y,\n          dx2 = p3.x - p2.x,\n          dy2 = p3.y - p2.y,\n          dx1p = dx1 * cos(quart) - dy1 * sin(quart),\n          dy1p = dx1 * sin(quart) + dy1 * cos(quart),\n          dx2p = dx2 * cos(quart) - dy2 * sin(quart),\n          dy2p = dx2 * sin(quart) + dy2 * cos(quart),\n          // chord midpoints\n    mx1 = (p1.x + p2.x) / 2,\n          my1 = (p1.y + p2.y) / 2,\n          mx2 = (p2.x + p3.x) / 2,\n          my2 = (p2.y + p3.y) / 2,\n          // midpoint offsets\n    mx1n = mx1 + dx1p,\n          my1n = my1 + dy1p,\n          mx2n = mx2 + dx2p,\n          my2n = my2 + dy2p,\n          // intersection of these lines:\n    arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n),\n          r = utils.dist(arc, p1); // arc start/end values, over mid point:\n\n    let s = atan2(p1.y - arc.y, p1.x - arc.x),\n        m = atan2(p2.y - arc.y, p2.x - arc.x),\n        e = atan2(p3.y - arc.y, p3.x - arc.x),\n        _; // determine arc direction (cw/ccw correction)\n\n\n    if (s < e) {\n      // if s<m<e, arc(s, e)\n      // if m<s<e, arc(e, s + tau)\n      // if s<e<m, arc(e, s + tau)\n      if (s > m || m > e) {\n        s += tau;\n      }\n\n      if (s > e) {\n        _ = e;\n        e = s;\n        s = _;\n      }\n    } else {\n      // if e<m<s, arc(e, s)\n      // if m<e<s, arc(s, e + tau)\n      // if e<s<m, arc(s, e + tau)\n      if (e < m && m < s) {\n        _ = e;\n        e = s;\n        s = _;\n      } else {\n        e += tau;\n      }\n    } // assign and done.\n\n\n    arc.s = s;\n    arc.e = e;\n    arc.r = r;\n    return arc;\n  },\n  numberSort: function (a, b) {\n    return a - b;\n  }\n};\n/**\n * Poly Bezier\n * @param {[type]} curves [description]\n */\n\nclass PolyBezier {\n  constructor(curves) {\n    this.curves = [];\n    this._3d = false;\n\n    if (!!curves) {\n      this.curves = curves;\n      this._3d = this.curves[0]._3d;\n    }\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return \"[\" + this.curves.map(function (curve) {\n      return utils.pointsToString(curve.points);\n    }).join(\", \") + \"]\";\n  }\n\n  addCurve(curve) {\n    this.curves.push(curve);\n    this._3d = this._3d || curve._3d;\n  }\n\n  length() {\n    return this.curves.map(function (v) {\n      return v.length();\n    }).reduce(function (a, b) {\n      return a + b;\n    });\n  }\n\n  curve(idx) {\n    return this.curves[idx];\n  }\n\n  bbox() {\n    const c = this.curves;\n    var bbox = c[0].bbox();\n\n    for (var i = 1; i < c.length; i++) {\n      utils.expandbox(bbox, c[i].bbox());\n    }\n\n    return bbox;\n  }\n\n  offset(d) {\n    const offset = [];\n    this.curves.forEach(function (v) {\n      offset.push(...v.offset(d));\n    });\n    return new PolyBezier(offset);\n  }\n\n}\n/**\n  A javascript Bezier curve library by Pomax.\n\n  Based on http://pomax.github.io/bezierinfo\n\n  This code is MIT licensed.\n**/\n// math-inlining.\n\n\nconst {\n  abs: abs$1,\n  min,\n  max,\n  cos: cos$1,\n  sin: sin$1,\n  acos: acos$1,\n  sqrt: sqrt$1\n} = Math;\nconst pi$1 = Math.PI;\n/**\n * Bezier curve constructor.\n *\n * ...docs pending...\n */\n\nclass Bezier {\n  constructor(coords) {\n    let args = coords && coords.forEach ? coords : Array.from(arguments).slice();\n    let coordlen = false;\n\n    if (typeof args[0] === \"object\") {\n      coordlen = args.length;\n      const newargs = [];\n      args.forEach(function (point) {\n        [\"x\", \"y\", \"z\"].forEach(function (d) {\n          if (typeof point[d] !== \"undefined\") {\n            newargs.push(point[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n\n    let higher = false;\n    const len = args.length;\n\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\"Only new Bezier(point[]) is accepted for 4th and higher order curves\");\n        }\n\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\"Only new Bezier(point[]) is accepted for 4th and higher order curves\");\n        }\n      }\n    }\n\n    const _3d = this._3d = !higher && (len === 9 || len === 12) || coords && coords[0] && typeof coords[0].z !== \"undefined\";\n\n    const points = this.points = [];\n\n    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1]\n      };\n\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n\n      points.push(point);\n    }\n\n    const order = this.order = points.length - 1;\n    const dims = this.dims = [\"x\", \"y\"];\n    if (_3d) dims.push(\"z\");\n    this.dimlen = dims.length;\n    const aligned = utils.align(points, {\n      p1: points[0],\n      p2: points[order]\n    });\n    this._linear = !aligned.some(p => abs$1(p.y) > 0.0001);\n    this._lut = [];\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  }\n\n  static quadraticFromPoints(p1, p2, p3, t) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } // shortcuts, although they're really dumb\n\n\n    if (t === 0) {\n      return new Bezier(p2, p2, p3);\n    }\n\n    if (t === 1) {\n      return new Bezier(p1, p2, p2);\n    } // real fitting.\n\n\n    const abc = Bezier.getABC(2, p1, p2, p3, t);\n    return new Bezier(p1, abc.A, p3);\n  }\n\n  static cubicFromPoints(S, B, E, t, d1) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n\n    const abc = Bezier.getABC(3, S, B, E, t);\n\n    if (typeof d1 === \"undefined\") {\n      d1 = utils.dist(B, abc.C);\n    }\n\n    const d2 = d1 * (1 - t) / t;\n    const selen = utils.dist(S, E),\n          lx = (E.x - S.x) / selen,\n          ly = (E.y - S.y) / selen,\n          bx1 = d1 * lx,\n          by1 = d1 * ly,\n          bx2 = d2 * lx,\n          by2 = d2 * ly; // derivation of new hull coordinates\n\n    const e1 = {\n      x: B.x - bx1,\n      y: B.y - by1\n    },\n          e2 = {\n      x: B.x + bx2,\n      y: B.y + by2\n    },\n          A = abc.A,\n          v1 = {\n      x: A.x + (e1.x - A.x) / (1 - t),\n      y: A.y + (e1.y - A.y) / (1 - t)\n    },\n          v2 = {\n      x: A.x + (e2.x - A.x) / t,\n      y: A.y + (e2.y - A.y) / t\n    },\n          nc1 = {\n      x: S.x + (v1.x - S.x) / t,\n      y: S.y + (v1.y - S.y) / t\n    },\n          nc2 = {\n      x: E.x + (v2.x - E.x) / (1 - t),\n      y: E.y + (v2.y - E.y) / (1 - t)\n    }; // ...done\n\n    return new Bezier(S, nc1, nc2, E);\n  }\n\n  static getUtils() {\n    return utils;\n  }\n\n  getUtils() {\n    return Bezier.getUtils();\n  }\n\n  static get PolyBezier() {\n    return PolyBezier;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return utils.pointsToString(this.points);\n  }\n\n  toSVG() {\n    if (this._3d) return false;\n    const p = this.points,\n          x = p[0].x,\n          y = p[0].y,\n          s = [\"M\", x, y, this.order === 2 ? \"Q\" : \"C\"];\n\n    for (let i = 1, last = p.length; i < last; i++) {\n      s.push(p[i].x);\n      s.push(p[i].y);\n    }\n\n    return s.join(\" \");\n  }\n\n  setRatios(ratios) {\n    if (ratios.length !== this.points.length) {\n      throw new Error(\"incorrect number of ratio values\");\n    }\n\n    this.ratios = ratios;\n    this._lut = []; //  invalidate any precomputed LUT\n  }\n\n  verify() {\n    const print = this.coordDigest();\n\n    if (print !== this._print) {\n      this._print = print;\n      this.update();\n    }\n  }\n\n  coordDigest() {\n    return this.points.map(function (c, pos) {\n      return \"\" + pos + c.x + c.y + (c.z ? c.z : 0);\n    }).join(\"\");\n  }\n\n  update() {\n    // invalidate any precomputed LUT\n    this._lut = [];\n    this.dpoints = utils.derive(this.points, this._3d);\n    this.computedirection();\n  }\n\n  computedirection() {\n    const points = this.points;\n    const angle = utils.angle(points[0], points[this.order], points[1]);\n    this.clockwise = angle > 0;\n  }\n\n  length() {\n    return utils.length(this.derivative.bind(this));\n  }\n\n  static getABC() {\n    let order = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n    let S = arguments.length > 1 ? arguments[1] : undefined;\n    let B = arguments.length > 2 ? arguments[2] : undefined;\n    let E = arguments.length > 3 ? arguments[3] : undefined;\n    let t = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;\n    const u = utils.projectionratio(t, order),\n          um = 1 - u,\n          C = {\n      x: u * S.x + um * E.x,\n      y: u * S.y + um * E.y\n    },\n          s = utils.abcratio(t, order),\n          A = {\n      x: B.x + (B.x - C.x) / s,\n      y: B.y + (B.y - C.y) / s\n    };\n    return {\n      A,\n      B,\n      C,\n      S,\n      E\n    };\n  }\n\n  getABC(t, B) {\n    B = B || this.get(t);\n    let S = this.points[0];\n    let E = this.points[this.order];\n    return Bezier.getABC(this.order, S, B, E, t);\n  }\n\n  getLUT(steps) {\n    this.verify();\n    steps = steps || 100;\n\n    if (this._lut.length === steps) {\n      return this._lut;\n    }\n\n    this._lut = []; // We want a range from 0 to 1 inclusive, so\n    // we decrement and then use <= rather than <:\n\n    steps--;\n\n    for (let i = 0, p, t; i < steps; i++) {\n      t = i / (steps - 1);\n      p = this.compute(t);\n      p.t = t;\n\n      this._lut.push(p);\n    }\n\n    return this._lut;\n  }\n\n  on(point, error) {\n    error = error || 5;\n    const lut = this.getLUT(),\n          hits = [];\n\n    for (let i = 0, c, t = 0; i < lut.length; i++) {\n      c = lut[i];\n\n      if (utils.dist(c, point) < error) {\n        hits.push(c);\n        t += i / lut.length;\n      }\n    }\n\n    if (!hits.length) return false;\n    return t /= hits.length;\n  }\n\n  project(point) {\n    // step 1: coarse check\n    const LUT = this.getLUT(),\n          l = LUT.length - 1,\n          closest = utils.closest(LUT, point),\n          mpos = closest.mpos,\n          t1 = (mpos - 1) / l,\n          t2 = (mpos + 1) / l,\n          step = 0.1 / l; // step 2: fine check\n\n    let mdist = closest.mdist,\n        t = t1,\n        ft = t,\n        p;\n    mdist += 1;\n\n    for (let d; t < t2 + step; t += step) {\n      p = this.compute(t);\n      d = utils.dist(point, p);\n\n      if (d < mdist) {\n        mdist = d;\n        ft = t;\n      }\n    }\n\n    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;\n    p = this.compute(ft);\n    p.t = ft;\n    p.d = mdist;\n    return p;\n  }\n\n  get(t) {\n    return this.compute(t);\n  }\n\n  point(idx) {\n    return this.points[idx];\n  }\n\n  compute(t) {\n    if (this.ratios) {\n      return utils.computeWithRatios(t, this.points, this.ratios, this._3d);\n    }\n\n    return utils.compute(t, this.points, this._3d, this.ratios);\n  }\n\n  raise() {\n    const p = this.points,\n          np = [p[0]],\n          k = p.length;\n\n    for (let i = 1, pi, pim; i < k; i++) {\n      pi = p[i];\n      pim = p[i - 1];\n      np[i] = {\n        x: (k - i) / k * pi.x + i / k * pim.x,\n        y: (k - i) / k * pi.y + i / k * pim.y\n      };\n    }\n\n    np[k] = p[k - 1];\n    return new Bezier(np);\n  }\n\n  derivative(t) {\n    return utils.compute(t, this.dpoints[0]);\n  }\n\n  dderivative(t) {\n    return utils.compute(t, this.dpoints[1]);\n  }\n\n  align() {\n    let p = this.points;\n    return new Bezier(utils.align(p, {\n      p1: p[0],\n      p2: p[p.length - 1]\n    }));\n  }\n\n  curvature(t) {\n    return utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);\n  }\n\n  inflections() {\n    return utils.inflections(this.points);\n  }\n\n  normal(t) {\n    return this._3d ? this.__normal3(t) : this.__normal2(t);\n  }\n\n  __normal2(t) {\n    const d = this.derivative(t);\n    const q = sqrt$1(d.x * d.x + d.y * d.y);\n    return {\n      x: -d.y / q,\n      y: d.x / q\n    };\n  }\n\n  __normal3(t) {\n    // see http://stackoverflow.com/questions/25453159\n    const r1 = this.derivative(t),\n          r2 = this.derivative(t + 0.01),\n          q1 = sqrt$1(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\n          q2 = sqrt$1(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n    r1.x /= q1;\n    r1.y /= q1;\n    r1.z /= q1;\n    r2.x /= q2;\n    r2.y /= q2;\n    r2.z /= q2; // cross product\n\n    const c = {\n      x: r2.y * r1.z - r2.z * r1.y,\n      y: r2.z * r1.x - r2.x * r1.z,\n      z: r2.x * r1.y - r2.y * r1.x\n    };\n    const m = sqrt$1(c.x * c.x + c.y * c.y + c.z * c.z);\n    c.x /= m;\n    c.y /= m;\n    c.z /= m; // rotation matrix\n\n    const R = [c.x * c.x, c.x * c.y - c.z, c.x * c.z + c.y, c.x * c.y + c.z, c.y * c.y, c.y * c.z - c.x, c.x * c.z - c.y, c.y * c.z + c.x, c.z * c.z]; // normal vector:\n\n    const n = {\n      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z\n    };\n    return n;\n  }\n\n  hull(t) {\n    let p = this.points,\n        _p = [],\n        q = [],\n        idx = 0;\n    q[idx++] = p[0];\n    q[idx++] = p[1];\n    q[idx++] = p[2];\n\n    if (this.order === 3) {\n      q[idx++] = p[3];\n    } // we lerp between all points at each iteration, until we have 1 point left.\n\n\n    while (p.length > 1) {\n      _p = [];\n\n      for (let i = 0, pt, l = p.length - 1; i < l; i++) {\n        pt = utils.lerp(t, p[i], p[i + 1]);\n        q[idx++] = pt;\n\n        _p.push(pt);\n      }\n\n      p = _p;\n    }\n\n    return q;\n  }\n\n  split(t1, t2) {\n    // shortcuts\n    if (t1 === 0 && !!t2) {\n      return this.split(t2).left;\n    }\n\n    if (t2 === 1) {\n      return this.split(t1).right;\n    } // no shortcut: use \"de Casteljau\" iteration.\n\n\n    const q = this.hull(t1);\n    const result = {\n      left: this.order === 2 ? new Bezier([q[0], q[3], q[5]]) : new Bezier([q[0], q[4], q[7], q[9]]),\n      right: this.order === 2 ? new Bezier([q[5], q[4], q[2]]) : new Bezier([q[9], q[8], q[6], q[3]]),\n      span: q\n    }; // make sure we bind _t1/_t2 information!\n\n    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\n    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2); // if we have no t2, we're done\n\n    if (!t2) {\n      return result;\n    } // if we have a t2, split again:\n\n\n    t2 = utils.map(t2, t1, 1, 0, 1);\n    return result.right.split(t2).left;\n  }\n\n  extrema() {\n    const result = {};\n    let roots = [];\n    this.dims.forEach(function (dim) {\n      let mfn = function (v) {\n        return v[dim];\n      };\n\n      let p = this.dpoints[0].map(mfn);\n      result[dim] = utils.droots(p);\n\n      if (this.order === 3) {\n        p = this.dpoints[1].map(mfn);\n        result[dim] = result[dim].concat(utils.droots(p));\n      }\n\n      result[dim] = result[dim].filter(function (t) {\n        return t >= 0 && t <= 1;\n      });\n      roots = roots.concat(result[dim].sort(utils.numberSort));\n    }.bind(this));\n    result.values = roots.sort(utils.numberSort).filter(function (v, idx) {\n      return roots.indexOf(v) === idx;\n    });\n    return result;\n  }\n\n  bbox() {\n    const extrema = this.extrema(),\n          result = {};\n    this.dims.forEach(function (d) {\n      result[d] = utils.getminmax(this, d, extrema[d]);\n    }.bind(this));\n    return result;\n  }\n\n  overlaps(curve) {\n    const lbbox = this.bbox(),\n          tbbox = curve.bbox();\n    return utils.bboxoverlap(lbbox, tbbox);\n  }\n\n  offset(t, d) {\n    if (typeof d !== \"undefined\") {\n      const c = this.get(t),\n            n = this.normal(t);\n      const ret = {\n        c: c,\n        n: n,\n        x: c.x + n.x * d,\n        y: c.y + n.y * d\n      };\n\n      if (this._3d) {\n        ret.z = c.z + n.z * d;\n      }\n\n      return ret;\n    }\n\n    if (this._linear) {\n      const nv = this.normal(0),\n            coords = this.points.map(function (p) {\n        const ret = {\n          x: p.x + t * nv.x,\n          y: p.y + t * nv.y\n        };\n\n        if (p.z && nv.z) {\n          ret.z = p.z + t * nv.z;\n        }\n\n        return ret;\n      });\n      return [new Bezier(coords)];\n    }\n\n    return this.reduce().map(function (s) {\n      if (s._linear) {\n        return s.offset(t)[0];\n      }\n\n      return s.scale(t);\n    });\n  }\n\n  simple() {\n    if (this.order === 3) {\n      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\n      const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\n      if (a1 > 0 && a2 < 0 || a1 < 0 && a2 > 0) return false;\n    }\n\n    const n1 = this.normal(0);\n    const n2 = this.normal(1);\n    let s = n1.x * n2.x + n1.y * n2.y;\n\n    if (this._3d) {\n      s += n1.z * n2.z;\n    }\n\n    return abs$1(acos$1(s)) < pi$1 / 3;\n  }\n\n  reduce() {\n    // TODO: examine these var types in more detail...\n    let i,\n        t1 = 0,\n        t2 = 0,\n        step = 0.01,\n        segment,\n        pass1 = [],\n        pass2 = []; // first pass: split on extrema\n\n    let extrema = this.extrema().values;\n\n    if (extrema.indexOf(0) === -1) {\n      extrema = [0].concat(extrema);\n    }\n\n    if (extrema.indexOf(1) === -1) {\n      extrema.push(1);\n    }\n\n    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n      t2 = extrema[i];\n      segment = this.split(t1, t2);\n      segment._t1 = t1;\n      segment._t2 = t2;\n      pass1.push(segment);\n      t1 = t2;\n    } // second pass: further reduce these segments to simple segments\n\n\n    pass1.forEach(function (p1) {\n      t1 = 0;\n      t2 = 0;\n\n      while (t2 <= 1) {\n        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n          segment = p1.split(t1, t2);\n\n          if (!segment.simple()) {\n            t2 -= step;\n\n            if (abs$1(t1 - t2) < step) {\n              // we can never form a reduction\n              return [];\n            }\n\n            segment = p1.split(t1, t2);\n            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n            segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\n            pass2.push(segment);\n            t1 = t2;\n            break;\n          }\n        }\n      }\n\n      if (t1 < 1) {\n        segment = p1.split(t1, 1);\n        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n        segment._t2 = p1._t2;\n        pass2.push(segment);\n      }\n    });\n    return pass2;\n  }\n\n  scale(d) {\n    const order = this.order;\n    let distanceFn = false;\n\n    if (typeof d === \"function\") {\n      distanceFn = d;\n    }\n\n    if (distanceFn && order === 2) {\n      return this.raise().scale(distanceFn);\n    } // TODO: add special handling for degenerate (=linear) curves.\n\n\n    const clockwise = this.clockwise;\n    const r1 = distanceFn ? distanceFn(0) : d;\n    const r2 = distanceFn ? distanceFn(1) : d;\n    const v = [this.offset(0, 10), this.offset(1, 10)];\n    const points = this.points;\n    const np = [];\n    const o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\n\n    if (!o) {\n      throw new Error(\"cannot scale this curve. Try reducing it first.\");\n    } // move all points by distance 'd' wrt the origin 'o'\n    // move end points by fixed distance along normal.\n\n\n    [0, 1].forEach(function (t) {\n      const p = np[t * order] = utils.copy(points[t * order]);\n      p.x += (t ? r2 : r1) * v[t].n.x;\n      p.y += (t ? r2 : r1) * v[t].n.y;\n    });\n\n    if (!distanceFn) {\n      // move control points to lie on the intersection of the offset\n      // derivative vector, and the origin-through-control vector\n      [0, 1].forEach(t => {\n        if (order === 2 && !!t) return;\n        const p = np[t * order];\n        const d = this.derivative(t);\n        const p2 = {\n          x: p.x + d.x,\n          y: p.y + d.y\n        };\n        np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);\n      });\n      return new Bezier(np);\n    } // move control points by \"however much necessary to\n    // ensure the correct tangent to endpoint\".\n\n\n    [0, 1].forEach(function (t) {\n      if (order === 2 && !!t) return;\n      var p = points[t + 1];\n      var ov = {\n        x: p.x - o.x,\n        y: p.y - o.y\n      };\n      var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n      if (distanceFn && !clockwise) rc = -rc;\n      var m = sqrt$1(ov.x * ov.x + ov.y * ov.y);\n      ov.x /= m;\n      ov.y /= m;\n      np[t + 1] = {\n        x: p.x + rc * ov.x,\n        y: p.y + rc * ov.y\n      };\n    });\n    return new Bezier(np);\n  }\n\n  outline(d1, d2, d3, d4) {\n    d2 = typeof d2 === \"undefined\" ? d1 : d2;\n    const reduced = this.reduce(),\n          len = reduced.length,\n          fcurves = [];\n    let bcurves = [],\n        p,\n        alen = 0,\n        tlen = this.length();\n    const graduated = typeof d3 !== \"undefined\" && typeof d4 !== \"undefined\";\n\n    function linearDistanceFunction(s, e, tlen, alen, slen) {\n      return function (v) {\n        const f1 = alen / tlen,\n              f2 = (alen + slen) / tlen,\n              d = e - s;\n        return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n      };\n    } // form curve oulines\n\n\n    reduced.forEach(function (segment) {\n      const slen = segment.length();\n\n      if (graduated) {\n        fcurves.push(segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen)));\n        bcurves.push(segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen)));\n      } else {\n        fcurves.push(segment.scale(d1));\n        bcurves.push(segment.scale(-d2));\n      }\n\n      alen += slen;\n    }); // reverse the \"return\" outline\n\n    bcurves = bcurves.map(function (s) {\n      p = s.points;\n\n      if (p[3]) {\n        s.points = [p[3], p[2], p[1], p[0]];\n      } else {\n        s.points = [p[2], p[1], p[0]];\n      }\n\n      return s;\n    }).reverse(); // form the endcaps as lines\n\n    const fs = fcurves[0].points[0],\n          fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\n          bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\n          be = bcurves[0].points[0],\n          ls = utils.makeline(bs, fs),\n          le = utils.makeline(fe, be),\n          segments = [ls].concat(fcurves).concat([le]).concat(bcurves);\n    return new PolyBezier(segments);\n  }\n\n  outlineshapes(d1, d2, curveIntersectionThreshold) {\n    d2 = d2 || d1;\n    const outline = this.outline(d1, d2).curves;\n    const shapes = [];\n\n    for (let i = 1, len = outline.length; i < len / 2; i++) {\n      const shape = utils.makeshape(outline[i], outline[len - i], curveIntersectionThreshold);\n      shape.startcap.virtual = i > 1;\n      shape.endcap.virtual = i < len / 2 - 1;\n      shapes.push(shape);\n    }\n\n    return shapes;\n  }\n\n  intersects(curve, curveIntersectionThreshold) {\n    if (!curve) return this.selfintersects(curveIntersectionThreshold);\n\n    if (curve.p1 && curve.p2) {\n      return this.lineIntersects(curve);\n    }\n\n    if (curve instanceof Bezier) {\n      curve = curve.reduce();\n    }\n\n    return this.curveintersects(this.reduce(), curve, curveIntersectionThreshold);\n  }\n\n  lineIntersects(line) {\n    const mx = min(line.p1.x, line.p2.x),\n          my = min(line.p1.y, line.p2.y),\n          MX = max(line.p1.x, line.p2.x),\n          MY = max(line.p1.y, line.p2.y);\n    return utils.roots(this.points, line).filter(t => {\n      var p = this.get(t);\n      return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\n    });\n  }\n\n  selfintersects(curveIntersectionThreshold) {\n    // \"simple\" curves cannot intersect with their direct\n    // neighbour, so for each segment X we check whether\n    // it intersects [0:x-2][x+2:last].\n    const reduced = this.reduce(),\n          len = reduced.length - 2,\n          results = [];\n\n    for (let i = 0, result, left, right; i < len; i++) {\n      left = reduced.slice(i, i + 1);\n      right = reduced.slice(i + 2);\n      result = this.curveintersects(left, right, curveIntersectionThreshold);\n      results.push(...result);\n    }\n\n    return results;\n  }\n\n  curveintersects(c1, c2, curveIntersectionThreshold) {\n    const pairs = []; // step 1: pair off any overlapping segments\n\n    c1.forEach(function (l) {\n      c2.forEach(function (r) {\n        if (l.overlaps(r)) {\n          pairs.push({\n            left: l,\n            right: r\n          });\n        }\n      });\n    }); // step 2: for each pairing, run through the convergence algorithm.\n\n    let intersections = [];\n    pairs.forEach(function (pair) {\n      const result = utils.pairiteration(pair.left, pair.right, curveIntersectionThreshold);\n\n      if (result.length > 0) {\n        intersections = intersections.concat(result);\n      }\n    });\n    return intersections;\n  }\n\n  arcs(errorThreshold) {\n    errorThreshold = errorThreshold || 0.5;\n    return this._iterate(errorThreshold, []);\n  }\n\n  _error(pc, np1, s, e) {\n    const q = (e - s) / 4,\n          c1 = this.get(s + q),\n          c2 = this.get(e - q),\n          ref = utils.dist(pc, np1),\n          d1 = utils.dist(pc, c1),\n          d2 = utils.dist(pc, c2);\n    return abs$1(d1 - ref) + abs$1(d2 - ref);\n  }\n\n  _iterate(errorThreshold, circles) {\n    let t_s = 0,\n        t_e = 1,\n        safety; // we do a binary search to find the \"good `t` closest to no-longer-good\"\n\n    do {\n      safety = 0; // step 1: start with the maximum possible arc\n\n      t_e = 1; // points:\n\n      let np1 = this.get(t_s),\n          np2,\n          np3,\n          arc,\n          prev_arc; // booleans:\n\n      let curr_good = false,\n          prev_good = false,\n          done; // numbers:\n\n      let t_m = t_e,\n          prev_e = 1; // step 2: find the best possible arc\n\n      do {\n        prev_good = curr_good;\n        prev_arc = arc;\n        t_m = (t_s + t_e) / 2;\n        np2 = this.get(t_m);\n        np3 = this.get(t_e);\n        arc = utils.getccenter(np1, np2, np3); //also save the t values\n\n        arc.interval = {\n          start: t_s,\n          end: t_e\n        };\n\n        let error = this._error(arc, np1, t_s, t_e);\n\n        curr_good = error <= errorThreshold;\n        done = prev_good && !curr_good;\n        if (!done) prev_e = t_e; // this arc is fine: we can move 'e' up to see if we can find a wider arc\n\n        if (curr_good) {\n          // if e is already at max, then we're done for this arc.\n          if (t_e >= 1) {\n            // make sure we cap at t=1\n            arc.interval.end = prev_e = 1;\n            prev_arc = arc; // if we capped the arc segment to t=1 we also need to make sure that\n            // the arc's end angle is correct with respect to the bezier end point.\n\n            if (t_e > 1) {\n              let d = {\n                x: arc.x + arc.r * cos$1(arc.e),\n                y: arc.y + arc.r * sin$1(arc.e)\n              };\n              arc.e += utils.angle({\n                x: arc.x,\n                y: arc.y\n              }, d, this.get(1));\n            }\n\n            break;\n          } // if not, move it up by half the iteration distance\n\n\n          t_e = t_e + (t_e - t_s) / 2;\n        } else {\n          // this is a bad arc: we need to move 'e' down to find a good arc\n          t_e = t_m;\n        }\n      } while (!done && safety++ < 100);\n\n      if (safety >= 100) {\n        break;\n      } // console.log(\"L835: [F] arc found\", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n\n      prev_arc = prev_arc ? prev_arc : arc;\n      circles.push(prev_arc);\n      t_s = prev_e;\n    } while (t_e < 1);\n\n    return circles;\n  }\n\n}\n\nexports.Bezier = Bezier;","map":{"version":3,"sources":["C:/SourceTree/capstone-project/node_modules/bezier-js/dist/bezier.common.js"],"names":["Object","defineProperty","exports","value","Bezier","abs","cos","sin","acos","atan2","sqrt","pow","Math","crt","v","pi","PI","tau","quart","epsilon","nMax","Number","MAX_SAFE_INTEGER","nMin","MIN_SAFE_INTEGER","ZERO","x","y","z","utils","Tvalues","Cvalues","arcfn","t","derivativeFn","d","l","compute","points","_3d","order","length","mt","p","ret","mt2","t2","a","b","c","dCpts","JSON","parse","stringify","i","splice","computeWithRatios","ratios","r","f1","f2","f3","f4","derive","dpoints","list","j","dpt","push","between","m","M","approximately","precision","len","sum","map","ds","de","ts","te","d1","d2","v2","lerp","v1","pointToString","s","pointsToString","join","copy","obj","angle","o","dx1","dy1","dx2","dy2","cross","dot","round","pos","indexOf","parseFloat","substring","dist","p1","p2","dx","dy","closest","LUT","point","mdist","mpos","forEach","idx","abcratio","n","bottom","top","projectionratio","lli8","x1","y1","x2","y2","x3","y3","x4","y4","nx","ny","lli4","p3","p4","lli","makeline","findbbox","sections","mx","my","MX","MY","bbox","min","max","mid","size","shapeintersections","s1","bbox1","s2","bbox2","curveIntersectionThreshold","bboxoverlap","intersections","a1","startcap","forward","back","endcap","a2","l1","virtual","l2","iss","intersects","c1","c2","makeshape","bpl","fpl","start","end","shape","getminmax","curve","concat","get","align","line","tx","ty","roots","aligned","reduce","m1","m2","filter","pa","pb","pc","pd","q","q2","discriminant","u1","mp3","mp33","cosphi","phi","crtr","t1","sd","droots","curvature","kOnly","num","dnm","adk","dk","k","dd","qdsum","pk","nk","inflections","slice","v3","trm","sq","b1","b2","dims","dim","expandbox","_bbox","pairiteration","c1b","c2b","threshold","_t1","_t2","cc1","split","cc2","pairs","left","right","pair","results","getccenter","dx1p","dy1p","dx2p","dy2p","mx1","my1","mx2","my2","mx1n","my1n","mx2n","my2n","arc","e","_","numberSort","PolyBezier","constructor","curves","valueOf","toString","addCurve","offset","abs$1","cos$1","sin$1","acos$1","sqrt$1","pi$1","coords","args","Array","from","arguments","coordlen","newargs","higher","Error","step","dimlen","_linear","some","_lut","update","quadraticFromPoints","abc","getABC","A","cubicFromPoints","S","B","E","C","selen","lx","ly","bx1","by1","bx2","by2","e1","e2","nc1","nc2","getUtils","toSVG","last","setRatios","verify","print","coordDigest","_print","computedirection","clockwise","derivative","bind","u","um","getLUT","steps","on","error","lut","hits","project","ft","raise","np","pim","dderivative","normal","__normal3","__normal2","r1","r2","q1","R","hull","_p","pt","result","span","extrema","mfn","sort","values","overlaps","lbbox","tbbox","nv","scale","simple","n1","n2","segment","pass1","pass2","distanceFn","ov","rc","outline","d3","d4","reduced","fcurves","bcurves","alen","tlen","graduated","linearDistanceFunction","slen","reverse","fs","fe","bs","be","ls","le","segments","outlineshapes","shapes","selfintersects","lineIntersects","curveintersects","arcs","errorThreshold","_iterate","_error","np1","ref","circles","t_s","t_e","safety","np2","np3","prev_arc","curr_good","prev_good","done","t_m","prev_e","interval"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Bezier = void 0;\n// math-inlining.\nconst {\n  abs,\n  cos,\n  sin,\n  acos,\n  atan2,\n  sqrt,\n  pow\n} = Math; // cube root function yielding real roots\n\nfunction crt(v) {\n  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);\n} // trig constants\n\n\nconst pi = Math.PI,\n      tau = 2 * pi,\n      quart = pi / 2,\n      // float precision significant decimal\nepsilon = 0.000001,\n      // extremas used in bbox calculation and similar algorithms\nnMax = Number.MAX_SAFE_INTEGER || 9007199254740991,\n      nMin = Number.MIN_SAFE_INTEGER || -9007199254740991,\n      // a zero coordinate, which is surprisingly useful\nZERO = {\n  x: 0,\n  y: 0,\n  z: 0\n}; // Bezier utility functions\n\nconst utils = {\n  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))\n  Tvalues: [-0.0640568928626056260850430826247450385909, 0.0640568928626056260850430826247450385909, -0.1911188674736163091586398207570696318404, 0.1911188674736163091586398207570696318404, -0.3150426796961633743867932913198102407864, 0.3150426796961633743867932913198102407864, -0.4337935076260451384870842319133497124524, 0.4337935076260451384870842319133497124524, -0.5454214713888395356583756172183723700107, 0.5454214713888395356583756172183723700107, -0.6480936519369755692524957869107476266696, 0.6480936519369755692524957869107476266696, -0.7401241915785543642438281030999784255232, 0.7401241915785543642438281030999784255232, -0.8200019859739029219539498726697452080761, 0.8200019859739029219539498726697452080761, -0.8864155270044010342131543419821967550873, 0.8864155270044010342131543419821967550873, -0.9382745520027327585236490017087214496548, 0.9382745520027327585236490017087214496548, -0.9747285559713094981983919930081690617411, 0.9747285559713094981983919930081690617411, -0.9951872199970213601799974097007368118745, 0.9951872199970213601799974097007368118745],\n  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)\n  Cvalues: [0.1279381953467521569740561652246953718517, 0.1279381953467521569740561652246953718517, 0.1258374563468282961213753825111836887264, 0.1258374563468282961213753825111836887264, 0.121670472927803391204463153476262425607, 0.121670472927803391204463153476262425607, 0.1155056680537256013533444839067835598622, 0.1155056680537256013533444839067835598622, 0.1074442701159656347825773424466062227946, 0.1074442701159656347825773424466062227946, 0.0976186521041138882698806644642471544279, 0.0976186521041138882698806644642471544279, 0.086190161531953275917185202983742667185, 0.086190161531953275917185202983742667185, 0.0733464814110803057340336152531165181193, 0.0733464814110803057340336152531165181193, 0.0592985849154367807463677585001085845412, 0.0592985849154367807463677585001085845412, 0.0442774388174198061686027482113382288593, 0.0442774388174198061686027482113382288593, 0.0285313886289336631813078159518782864491, 0.0285313886289336631813078159518782864491, 0.0123412297999871995468056670700372915759, 0.0123412297999871995468056670700372915759],\n  arcfn: function (t, derivativeFn) {\n    const d = derivativeFn(t);\n    let l = d.x * d.x + d.y * d.y;\n\n    if (typeof d.z !== \"undefined\") {\n      l += d.z * d.z;\n    }\n\n    return sqrt(l);\n  },\n  compute: function (t, points, _3d) {\n    // shortcuts\n    if (t === 0) {\n      points[0].t = 0;\n      return points[0];\n    }\n\n    const order = points.length - 1;\n\n    if (t === 1) {\n      points[order].t = 1;\n      return points[order];\n    }\n\n    const mt = 1 - t;\n    let p = points; // constant?\n\n    if (order === 0) {\n      points[0].t = t;\n      return points[0];\n    } // linear?\n\n\n    if (order === 1) {\n      const ret = {\n        x: mt * p[0].x + t * p[1].x,\n        y: mt * p[0].y + t * p[1].y,\n        t: t\n      };\n\n      if (_3d) {\n        ret.z = mt * p[0].z + t * p[1].z;\n      }\n\n      return ret;\n    } // quadratic/cubic curve?\n\n\n    if (order < 4) {\n      let mt2 = mt * mt,\n          t2 = t * t,\n          a,\n          b,\n          c,\n          d = 0;\n\n      if (order === 2) {\n        p = [p[0], p[1], p[2], ZERO];\n        a = mt2;\n        b = mt * t * 2;\n        c = t2;\n      } else if (order === 3) {\n        a = mt2 * mt;\n        b = mt2 * t * 3;\n        c = mt * t2 * 3;\n        d = t * t2;\n      }\n\n      const ret = {\n        x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,\n        y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,\n        t: t\n      };\n\n      if (_3d) {\n        ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;\n      }\n\n      return ret;\n    } // higher order curves: use de Casteljau's computation\n\n\n    const dCpts = JSON.parse(JSON.stringify(points));\n\n    while (dCpts.length > 1) {\n      for (let i = 0; i < dCpts.length - 1; i++) {\n        dCpts[i] = {\n          x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t,\n          y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t\n        };\n\n        if (typeof dCpts[i].z !== \"undefined\") {\n          dCpts[i] = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t;\n        }\n      }\n\n      dCpts.splice(dCpts.length - 1, 1);\n    }\n\n    dCpts[0].t = t;\n    return dCpts[0];\n  },\n  computeWithRatios: function (t, points, ratios, _3d) {\n    const mt = 1 - t,\n          r = ratios,\n          p = points;\n    let f1 = r[0],\n        f2 = r[1],\n        f3 = r[2],\n        f4 = r[3],\n        d; // spec for linear\n\n    f1 *= mt;\n    f2 *= t;\n\n    if (p.length === 2) {\n      d = f1 + f2;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z) / d,\n        t: t\n      };\n    } // upgrade to quadratic\n\n\n    f1 *= mt;\n    f2 *= 2 * mt;\n    f3 *= t * t;\n\n    if (p.length === 3) {\n      d = f1 + f2 + f3;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d,\n        t: t\n      };\n    } // upgrade to cubic\n\n\n    f1 *= mt;\n    f2 *= 1.5 * mt;\n    f3 *= 3 * mt;\n    f4 *= t * t * t;\n\n    if (p.length === 4) {\n      d = f1 + f2 + f3 + f4;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d,\n        t: t\n      };\n    }\n  },\n  derive: function (points, _3d) {\n    const dpoints = [];\n\n    for (let p = points, d = p.length, c = d - 1; d > 1; d--, c--) {\n      const list = [];\n\n      for (let j = 0, dpt; j < c; j++) {\n        dpt = {\n          x: c * (p[j + 1].x - p[j].x),\n          y: c * (p[j + 1].y - p[j].y)\n        };\n\n        if (_3d) {\n          dpt.z = c * (p[j + 1].z - p[j].z);\n        }\n\n        list.push(dpt);\n      }\n\n      dpoints.push(list);\n      p = list;\n    }\n\n    return dpoints;\n  },\n  between: function (v, m, M) {\n    return m <= v && v <= M || utils.approximately(v, m) || utils.approximately(v, M);\n  },\n  approximately: function (a, b, precision) {\n    return abs(a - b) <= (precision || epsilon);\n  },\n  length: function (derivativeFn) {\n    const z = 0.5,\n          len = utils.Tvalues.length;\n    let sum = 0;\n\n    for (let i = 0, t; i < len; i++) {\n      t = z * utils.Tvalues[i] + z;\n      sum += utils.Cvalues[i] * utils.arcfn(t, derivativeFn);\n    }\n\n    return z * sum;\n  },\n  map: function (v, ds, de, ts, te) {\n    const d1 = de - ds,\n          d2 = te - ts,\n          v2 = v - ds,\n          r = v2 / d1;\n    return ts + d2 * r;\n  },\n  lerp: function (r, v1, v2) {\n    const ret = {\n      x: v1.x + r * (v2.x - v1.x),\n      y: v1.y + r * (v2.y - v1.y)\n    };\n\n    if (!!v1.z && !!v2.z) {\n      ret.z = v1.z + r * (v2.z - v1.z);\n    }\n\n    return ret;\n  },\n  pointToString: function (p) {\n    let s = p.x + \"/\" + p.y;\n\n    if (typeof p.z !== \"undefined\") {\n      s += \"/\" + p.z;\n    }\n\n    return s;\n  },\n  pointsToString: function (points) {\n    return \"[\" + points.map(utils.pointToString).join(\", \") + \"]\";\n  },\n  copy: function (obj) {\n    return JSON.parse(JSON.stringify(obj));\n  },\n  angle: function (o, v1, v2) {\n    const dx1 = v1.x - o.x,\n          dy1 = v1.y - o.y,\n          dx2 = v2.x - o.x,\n          dy2 = v2.y - o.y,\n          cross = dx1 * dy2 - dy1 * dx2,\n          dot = dx1 * dx2 + dy1 * dy2;\n    return atan2(cross, dot);\n  },\n  // round as string, to avoid rounding errors\n  round: function (v, d) {\n    const s = \"\" + v;\n    const pos = s.indexOf(\".\");\n    return parseFloat(s.substring(0, pos + 1 + d));\n  },\n  dist: function (p1, p2) {\n    const dx = p1.x - p2.x,\n          dy = p1.y - p2.y;\n    return sqrt(dx * dx + dy * dy);\n  },\n  closest: function (LUT, point) {\n    let mdist = pow(2, 63),\n        mpos,\n        d;\n    LUT.forEach(function (p, idx) {\n      d = utils.dist(point, p);\n\n      if (d < mdist) {\n        mdist = d;\n        mpos = idx;\n      }\n    });\n    return {\n      mdist: mdist,\n      mpos: mpos\n    };\n  },\n  abcratio: function (t, n) {\n    // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n\n    const bottom = pow(t, n) + pow(1 - t, n),\n          top = bottom - 1;\n    return abs(top / bottom);\n  },\n  projectionratio: function (t, n) {\n    // see u(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n\n    const top = pow(1 - t, n),\n          bottom = pow(t, n) + top;\n    return top / bottom;\n  },\n  lli8: function (x1, y1, x2, y2, x3, y3, x4, y4) {\n    const nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n          ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n          d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n\n    if (d == 0) {\n      return false;\n    }\n\n    return {\n      x: nx / d,\n      y: ny / d\n    };\n  },\n  lli4: function (p1, p2, p3, p4) {\n    const x1 = p1.x,\n          y1 = p1.y,\n          x2 = p2.x,\n          y2 = p2.y,\n          x3 = p3.x,\n          y3 = p3.y,\n          x4 = p4.x,\n          y4 = p4.y;\n    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);\n  },\n  lli: function (v1, v2) {\n    return utils.lli4(v1, v1.c, v2, v2.c);\n  },\n  makeline: function (p1, p2) {\n    const x1 = p1.x,\n          y1 = p1.y,\n          x2 = p2.x,\n          y2 = p2.y,\n          dx = (x2 - x1) / 3,\n          dy = (y2 - y1) / 3;\n    return new Bezier(x1, y1, x1 + dx, y1 + dy, x1 + 2 * dx, y1 + 2 * dy, x2, y2);\n  },\n  findbbox: function (sections) {\n    let mx = nMax,\n        my = nMax,\n        MX = nMin,\n        MY = nMin;\n    sections.forEach(function (s) {\n      const bbox = s.bbox();\n      if (mx > bbox.x.min) mx = bbox.x.min;\n      if (my > bbox.y.min) my = bbox.y.min;\n      if (MX < bbox.x.max) MX = bbox.x.max;\n      if (MY < bbox.y.max) MY = bbox.y.max;\n    });\n    return {\n      x: {\n        min: mx,\n        mid: (mx + MX) / 2,\n        max: MX,\n        size: MX - mx\n      },\n      y: {\n        min: my,\n        mid: (my + MY) / 2,\n        max: MY,\n        size: MY - my\n      }\n    };\n  },\n  shapeintersections: function (s1, bbox1, s2, bbox2, curveIntersectionThreshold) {\n    if (!utils.bboxoverlap(bbox1, bbox2)) return [];\n    const intersections = [];\n    const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];\n    const a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];\n    a1.forEach(function (l1) {\n      if (l1.virtual) return;\n      a2.forEach(function (l2) {\n        if (l2.virtual) return;\n        const iss = l1.intersects(l2, curveIntersectionThreshold);\n\n        if (iss.length > 0) {\n          iss.c1 = l1;\n          iss.c2 = l2;\n          iss.s1 = s1;\n          iss.s2 = s2;\n          intersections.push(iss);\n        }\n      });\n    });\n    return intersections;\n  },\n  makeshape: function (forward, back, curveIntersectionThreshold) {\n    const bpl = back.points.length;\n    const fpl = forward.points.length;\n    const start = utils.makeline(back.points[bpl - 1], forward.points[0]);\n    const end = utils.makeline(forward.points[fpl - 1], back.points[0]);\n    const shape = {\n      startcap: start,\n      forward: forward,\n      back: back,\n      endcap: end,\n      bbox: utils.findbbox([start, forward, back, end])\n    };\n\n    shape.intersections = function (s2) {\n      return utils.shapeintersections(shape, shape.bbox, s2, s2.bbox, curveIntersectionThreshold);\n    };\n\n    return shape;\n  },\n  getminmax: function (curve, d, list) {\n    if (!list) return {\n      min: 0,\n      max: 0\n    };\n    let min = nMax,\n        max = nMin,\n        t,\n        c;\n\n    if (list.indexOf(0) === -1) {\n      list = [0].concat(list);\n    }\n\n    if (list.indexOf(1) === -1) {\n      list.push(1);\n    }\n\n    for (let i = 0, len = list.length; i < len; i++) {\n      t = list[i];\n      c = curve.get(t);\n\n      if (c[d] < min) {\n        min = c[d];\n      }\n\n      if (c[d] > max) {\n        max = c[d];\n      }\n    }\n\n    return {\n      min: min,\n      mid: (min + max) / 2,\n      max: max,\n      size: max - min\n    };\n  },\n  align: function (points, line) {\n    const tx = line.p1.x,\n          ty = line.p1.y,\n          a = -atan2(line.p2.y - ty, line.p2.x - tx),\n          d = function (v) {\n      return {\n        x: (v.x - tx) * cos(a) - (v.y - ty) * sin(a),\n        y: (v.x - tx) * sin(a) + (v.y - ty) * cos(a)\n      };\n    };\n\n    return points.map(d);\n  },\n  roots: function (points, line) {\n    line = line || {\n      p1: {\n        x: 0,\n        y: 0\n      },\n      p2: {\n        x: 1,\n        y: 0\n      }\n    };\n    const order = points.length - 1;\n    const aligned = utils.align(points, line);\n\n    const reduce = function (t) {\n      return 0 <= t && t <= 1;\n    };\n\n    if (order === 2) {\n      const a = aligned[0].y,\n            b = aligned[1].y,\n            c = aligned[2].y,\n            d = a - 2 * b + c;\n\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n              m2 = -a + b,\n              v1 = -(m1 + m2) / d,\n              v2 = -(-m1 + m2) / d;\n        return [v1, v2].filter(reduce);\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * b - 2 * c)].filter(reduce);\n      }\n\n      return [];\n    } // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm\n\n\n    const pa = aligned[0].y,\n          pb = aligned[1].y,\n          pc = aligned[2].y,\n          pd = aligned[3].y;\n    let d = -pa + 3 * pb - 3 * pc + pd,\n        a = 3 * pa - 6 * pb + 3 * pc,\n        b = -3 * pa + 3 * pb,\n        c = pa;\n\n    if (utils.approximately(d, 0)) {\n      // this is not a cubic curve.\n      if (utils.approximately(a, 0)) {\n        // in fact, this is not a quadratic curve either.\n        if (utils.approximately(b, 0)) {\n          // in fact in fact, there are no solutions.\n          return [];\n        } // linear solution:\n\n\n        return [-c / b].filter(reduce);\n      } // quadratic solution:\n\n\n      const q = sqrt(b * b - 4 * a * c),\n            a2 = 2 * a;\n      return [(q - b) / a2, (-b - q) / a2].filter(reduce);\n    } // at this point, we know we need a cubic solution:\n\n\n    a /= d;\n    b /= d;\n    c /= d;\n    const p = (3 * b - a * a) / 3,\n          p3 = p / 3,\n          q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,\n          q2 = q / 2,\n          discriminant = q2 * q2 + p3 * p3 * p3;\n    let u1, v1, x1, x2, x3;\n\n    if (discriminant < 0) {\n      const mp3 = -p / 3,\n            mp33 = mp3 * mp3 * mp3,\n            r = sqrt(mp33),\n            t = -q / (2 * r),\n            cosphi = t < -1 ? -1 : t > 1 ? 1 : t,\n            phi = acos(cosphi),\n            crtr = crt(r),\n            t1 = 2 * crtr;\n      x1 = t1 * cos(phi / 3) - a / 3;\n      x2 = t1 * cos((phi + tau) / 3) - a / 3;\n      x3 = t1 * cos((phi + 2 * tau) / 3) - a / 3;\n      return [x1, x2, x3].filter(reduce);\n    } else if (discriminant === 0) {\n      u1 = q2 < 0 ? crt(-q2) : -crt(q2);\n      x1 = 2 * u1 - a / 3;\n      x2 = -u1 - a / 3;\n      return [x1, x2].filter(reduce);\n    } else {\n      const sd = sqrt(discriminant);\n      u1 = crt(-q2 + sd);\n      v1 = crt(q2 + sd);\n      return [u1 - v1 - a / 3].filter(reduce);\n    }\n  },\n  droots: function (p) {\n    // quadratic roots are easy\n    if (p.length === 3) {\n      const a = p[0],\n            b = p[1],\n            c = p[2],\n            d = a - 2 * b + c;\n\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n              m2 = -a + b,\n              v1 = -(m1 + m2) / d,\n              v2 = -(-m1 + m2) / d;\n        return [v1, v2];\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * (b - c))];\n      }\n\n      return [];\n    } // linear roots are even easier\n\n\n    if (p.length === 2) {\n      const a = p[0],\n            b = p[1];\n\n      if (a !== b) {\n        return [a / (a - b)];\n      }\n\n      return [];\n    }\n\n    return [];\n  },\n  curvature: function (t, d1, d2, _3d, kOnly) {\n    let num,\n        dnm,\n        adk,\n        dk,\n        k = 0,\n        r = 0; //\n    // We're using the following formula for curvature:\n    //\n    //              x'y\" - y'x\"\n    //   k(t) = ------------------\n    //           (x'² + y'²)^(3/2)\n    //\n    // from https://en.wikipedia.org/wiki/Radius_of_curvature#Definition\n    //\n    // With it corresponding 3D counterpart:\n    //\n    //          sqrt( (y'z\" - y\"z')² + (z'x\" - z\"x')² + (x'y\" - x\"y')²)\n    //   k(t) = -------------------------------------------------------\n    //                     (x'² + y'² + z'²)^(3/2)\n    //\n\n    const d = utils.compute(t, d1);\n    const dd = utils.compute(t, d2);\n    const qdsum = d.x * d.x + d.y * d.y;\n\n    if (_3d) {\n      num = sqrt(pow(d.y * dd.z - dd.y * d.z, 2) + pow(d.z * dd.x - dd.z * d.x, 2) + pow(d.x * dd.y - dd.x * d.y, 2));\n      dnm = pow(qdsum + d.z * d.z, 3 / 2);\n    } else {\n      num = d.x * dd.y - d.y * dd.x;\n      dnm = pow(qdsum, 3 / 2);\n    }\n\n    if (num === 0 || dnm === 0) {\n      return {\n        k: 0,\n        r: 0\n      };\n    }\n\n    k = num / dnm;\n    r = dnm / num; // We're also computing the derivative of kappa, because\n    // there is value in knowing the rate of change for the\n    // curvature along the curve. And we're just going to\n    // ballpark it based on an epsilon.\n\n    if (!kOnly) {\n      // compute k'(t) based on the interval before, and after it,\n      // to at least try to not introduce forward/backward pass bias.\n      const pk = utils.curvature(t - 0.001, d1, d2, _3d, true).k;\n      const nk = utils.curvature(t + 0.001, d1, d2, _3d, true).k;\n      dk = (nk - k + (k - pk)) / 2;\n      adk = (abs(nk - k) + abs(k - pk)) / 2;\n    }\n\n    return {\n      k: k,\n      r: r,\n      dk: dk,\n      adk: adk\n    };\n  },\n  inflections: function (points) {\n    if (points.length < 4) return []; // FIXME: TODO: add in inflection abstraction for quartic+ curves?\n\n    const p = utils.align(points, {\n      p1: points[0],\n      p2: points.slice(-1)[0]\n    }),\n          a = p[2].x * p[1].y,\n          b = p[3].x * p[1].y,\n          c = p[1].x * p[2].y,\n          d = p[3].x * p[2].y,\n          v1 = 18 * (-3 * a + 2 * b + 3 * c - d),\n          v2 = 18 * (3 * a - b - 3 * c),\n          v3 = 18 * (c - a);\n\n    if (utils.approximately(v1, 0)) {\n      if (!utils.approximately(v2, 0)) {\n        let t = -v3 / v2;\n        if (0 <= t && t <= 1) return [t];\n      }\n\n      return [];\n    }\n\n    const trm = v2 * v2 - 4 * v1 * v3,\n          sq = Math.sqrt(trm),\n          d2 = 2 * v1;\n    if (utils.approximately(d2, 0)) return [];\n    return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function (r) {\n      return 0 <= r && r <= 1;\n    });\n  },\n  bboxoverlap: function (b1, b2) {\n    const dims = [\"x\", \"y\"],\n          len = dims.length;\n\n    for (let i = 0, dim, l, t, d; i < len; i++) {\n      dim = dims[i];\n      l = b1[dim].mid;\n      t = b2[dim].mid;\n      d = (b1[dim].size + b2[dim].size) / 2;\n      if (abs(l - t) >= d) return false;\n    }\n\n    return true;\n  },\n  expandbox: function (bbox, _bbox) {\n    if (_bbox.x.min < bbox.x.min) {\n      bbox.x.min = _bbox.x.min;\n    }\n\n    if (_bbox.y.min < bbox.y.min) {\n      bbox.y.min = _bbox.y.min;\n    }\n\n    if (_bbox.z && _bbox.z.min < bbox.z.min) {\n      bbox.z.min = _bbox.z.min;\n    }\n\n    if (_bbox.x.max > bbox.x.max) {\n      bbox.x.max = _bbox.x.max;\n    }\n\n    if (_bbox.y.max > bbox.y.max) {\n      bbox.y.max = _bbox.y.max;\n    }\n\n    if (_bbox.z && _bbox.z.max > bbox.z.max) {\n      bbox.z.max = _bbox.z.max;\n    }\n\n    bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;\n    bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;\n\n    if (bbox.z) {\n      bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;\n    }\n\n    bbox.x.size = bbox.x.max - bbox.x.min;\n    bbox.y.size = bbox.y.max - bbox.y.min;\n\n    if (bbox.z) {\n      bbox.z.size = bbox.z.max - bbox.z.min;\n    }\n  },\n  pairiteration: function (c1, c2, curveIntersectionThreshold) {\n    const c1b = c1.bbox(),\n          c2b = c2.bbox(),\n          r = 100000,\n          threshold = curveIntersectionThreshold || 0.5;\n\n    if (c1b.x.size + c1b.y.size < threshold && c2b.x.size + c2b.y.size < threshold) {\n      return [(r * (c1._t1 + c1._t2) / 2 | 0) / r + \"/\" + (r * (c2._t1 + c2._t2) / 2 | 0) / r];\n    }\n\n    let cc1 = c1.split(0.5),\n        cc2 = c2.split(0.5),\n        pairs = [{\n      left: cc1.left,\n      right: cc2.left\n    }, {\n      left: cc1.left,\n      right: cc2.right\n    }, {\n      left: cc1.right,\n      right: cc2.right\n    }, {\n      left: cc1.right,\n      right: cc2.left\n    }];\n    pairs = pairs.filter(function (pair) {\n      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());\n    });\n    let results = [];\n    if (pairs.length === 0) return results;\n    pairs.forEach(function (pair) {\n      results = results.concat(utils.pairiteration(pair.left, pair.right, threshold));\n    });\n    results = results.filter(function (v, i) {\n      return results.indexOf(v) === i;\n    });\n    return results;\n  },\n  getccenter: function (p1, p2, p3) {\n    const dx1 = p2.x - p1.x,\n          dy1 = p2.y - p1.y,\n          dx2 = p3.x - p2.x,\n          dy2 = p3.y - p2.y,\n          dx1p = dx1 * cos(quart) - dy1 * sin(quart),\n          dy1p = dx1 * sin(quart) + dy1 * cos(quart),\n          dx2p = dx2 * cos(quart) - dy2 * sin(quart),\n          dy2p = dx2 * sin(quart) + dy2 * cos(quart),\n          // chord midpoints\n    mx1 = (p1.x + p2.x) / 2,\n          my1 = (p1.y + p2.y) / 2,\n          mx2 = (p2.x + p3.x) / 2,\n          my2 = (p2.y + p3.y) / 2,\n          // midpoint offsets\n    mx1n = mx1 + dx1p,\n          my1n = my1 + dy1p,\n          mx2n = mx2 + dx2p,\n          my2n = my2 + dy2p,\n          // intersection of these lines:\n    arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n),\n          r = utils.dist(arc, p1); // arc start/end values, over mid point:\n\n    let s = atan2(p1.y - arc.y, p1.x - arc.x),\n        m = atan2(p2.y - arc.y, p2.x - arc.x),\n        e = atan2(p3.y - arc.y, p3.x - arc.x),\n        _; // determine arc direction (cw/ccw correction)\n\n\n    if (s < e) {\n      // if s<m<e, arc(s, e)\n      // if m<s<e, arc(e, s + tau)\n      // if s<e<m, arc(e, s + tau)\n      if (s > m || m > e) {\n        s += tau;\n      }\n\n      if (s > e) {\n        _ = e;\n        e = s;\n        s = _;\n      }\n    } else {\n      // if e<m<s, arc(e, s)\n      // if m<e<s, arc(s, e + tau)\n      // if e<s<m, arc(s, e + tau)\n      if (e < m && m < s) {\n        _ = e;\n        e = s;\n        s = _;\n      } else {\n        e += tau;\n      }\n    } // assign and done.\n\n\n    arc.s = s;\n    arc.e = e;\n    arc.r = r;\n    return arc;\n  },\n  numberSort: function (a, b) {\n    return a - b;\n  }\n};\n/**\n * Poly Bezier\n * @param {[type]} curves [description]\n */\n\nclass PolyBezier {\n  constructor(curves) {\n    this.curves = [];\n    this._3d = false;\n\n    if (!!curves) {\n      this.curves = curves;\n      this._3d = this.curves[0]._3d;\n    }\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return \"[\" + this.curves.map(function (curve) {\n      return utils.pointsToString(curve.points);\n    }).join(\", \") + \"]\";\n  }\n\n  addCurve(curve) {\n    this.curves.push(curve);\n    this._3d = this._3d || curve._3d;\n  }\n\n  length() {\n    return this.curves.map(function (v) {\n      return v.length();\n    }).reduce(function (a, b) {\n      return a + b;\n    });\n  }\n\n  curve(idx) {\n    return this.curves[idx];\n  }\n\n  bbox() {\n    const c = this.curves;\n    var bbox = c[0].bbox();\n\n    for (var i = 1; i < c.length; i++) {\n      utils.expandbox(bbox, c[i].bbox());\n    }\n\n    return bbox;\n  }\n\n  offset(d) {\n    const offset = [];\n    this.curves.forEach(function (v) {\n      offset.push(...v.offset(d));\n    });\n    return new PolyBezier(offset);\n  }\n\n}\n/**\n  A javascript Bezier curve library by Pomax.\n\n  Based on http://pomax.github.io/bezierinfo\n\n  This code is MIT licensed.\n**/\n// math-inlining.\n\n\nconst {\n  abs: abs$1,\n  min,\n  max,\n  cos: cos$1,\n  sin: sin$1,\n  acos: acos$1,\n  sqrt: sqrt$1\n} = Math;\nconst pi$1 = Math.PI;\n/**\n * Bezier curve constructor.\n *\n * ...docs pending...\n */\n\nclass Bezier {\n  constructor(coords) {\n    let args = coords && coords.forEach ? coords : Array.from(arguments).slice();\n    let coordlen = false;\n\n    if (typeof args[0] === \"object\") {\n      coordlen = args.length;\n      const newargs = [];\n      args.forEach(function (point) {\n        [\"x\", \"y\", \"z\"].forEach(function (d) {\n          if (typeof point[d] !== \"undefined\") {\n            newargs.push(point[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n\n    let higher = false;\n    const len = args.length;\n\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\"Only new Bezier(point[]) is accepted for 4th and higher order curves\");\n        }\n\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\"Only new Bezier(point[]) is accepted for 4th and higher order curves\");\n        }\n      }\n    }\n\n    const _3d = this._3d = !higher && (len === 9 || len === 12) || coords && coords[0] && typeof coords[0].z !== \"undefined\";\n\n    const points = this.points = [];\n\n    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1]\n      };\n\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n\n      points.push(point);\n    }\n\n    const order = this.order = points.length - 1;\n    const dims = this.dims = [\"x\", \"y\"];\n    if (_3d) dims.push(\"z\");\n    this.dimlen = dims.length;\n    const aligned = utils.align(points, {\n      p1: points[0],\n      p2: points[order]\n    });\n    this._linear = !aligned.some(p => abs$1(p.y) > 0.0001);\n    this._lut = [];\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  }\n\n  static quadraticFromPoints(p1, p2, p3, t) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } // shortcuts, although they're really dumb\n\n\n    if (t === 0) {\n      return new Bezier(p2, p2, p3);\n    }\n\n    if (t === 1) {\n      return new Bezier(p1, p2, p2);\n    } // real fitting.\n\n\n    const abc = Bezier.getABC(2, p1, p2, p3, t);\n    return new Bezier(p1, abc.A, p3);\n  }\n\n  static cubicFromPoints(S, B, E, t, d1) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n\n    const abc = Bezier.getABC(3, S, B, E, t);\n\n    if (typeof d1 === \"undefined\") {\n      d1 = utils.dist(B, abc.C);\n    }\n\n    const d2 = d1 * (1 - t) / t;\n    const selen = utils.dist(S, E),\n          lx = (E.x - S.x) / selen,\n          ly = (E.y - S.y) / selen,\n          bx1 = d1 * lx,\n          by1 = d1 * ly,\n          bx2 = d2 * lx,\n          by2 = d2 * ly; // derivation of new hull coordinates\n\n    const e1 = {\n      x: B.x - bx1,\n      y: B.y - by1\n    },\n          e2 = {\n      x: B.x + bx2,\n      y: B.y + by2\n    },\n          A = abc.A,\n          v1 = {\n      x: A.x + (e1.x - A.x) / (1 - t),\n      y: A.y + (e1.y - A.y) / (1 - t)\n    },\n          v2 = {\n      x: A.x + (e2.x - A.x) / t,\n      y: A.y + (e2.y - A.y) / t\n    },\n          nc1 = {\n      x: S.x + (v1.x - S.x) / t,\n      y: S.y + (v1.y - S.y) / t\n    },\n          nc2 = {\n      x: E.x + (v2.x - E.x) / (1 - t),\n      y: E.y + (v2.y - E.y) / (1 - t)\n    }; // ...done\n\n    return new Bezier(S, nc1, nc2, E);\n  }\n\n  static getUtils() {\n    return utils;\n  }\n\n  getUtils() {\n    return Bezier.getUtils();\n  }\n\n  static get PolyBezier() {\n    return PolyBezier;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return utils.pointsToString(this.points);\n  }\n\n  toSVG() {\n    if (this._3d) return false;\n    const p = this.points,\n          x = p[0].x,\n          y = p[0].y,\n          s = [\"M\", x, y, this.order === 2 ? \"Q\" : \"C\"];\n\n    for (let i = 1, last = p.length; i < last; i++) {\n      s.push(p[i].x);\n      s.push(p[i].y);\n    }\n\n    return s.join(\" \");\n  }\n\n  setRatios(ratios) {\n    if (ratios.length !== this.points.length) {\n      throw new Error(\"incorrect number of ratio values\");\n    }\n\n    this.ratios = ratios;\n    this._lut = []; //  invalidate any precomputed LUT\n  }\n\n  verify() {\n    const print = this.coordDigest();\n\n    if (print !== this._print) {\n      this._print = print;\n      this.update();\n    }\n  }\n\n  coordDigest() {\n    return this.points.map(function (c, pos) {\n      return \"\" + pos + c.x + c.y + (c.z ? c.z : 0);\n    }).join(\"\");\n  }\n\n  update() {\n    // invalidate any precomputed LUT\n    this._lut = [];\n    this.dpoints = utils.derive(this.points, this._3d);\n    this.computedirection();\n  }\n\n  computedirection() {\n    const points = this.points;\n    const angle = utils.angle(points[0], points[this.order], points[1]);\n    this.clockwise = angle > 0;\n  }\n\n  length() {\n    return utils.length(this.derivative.bind(this));\n  }\n\n  static getABC(order = 2, S, B, E, t = 0.5) {\n    const u = utils.projectionratio(t, order),\n          um = 1 - u,\n          C = {\n      x: u * S.x + um * E.x,\n      y: u * S.y + um * E.y\n    },\n          s = utils.abcratio(t, order),\n          A = {\n      x: B.x + (B.x - C.x) / s,\n      y: B.y + (B.y - C.y) / s\n    };\n    return {\n      A,\n      B,\n      C,\n      S,\n      E\n    };\n  }\n\n  getABC(t, B) {\n    B = B || this.get(t);\n    let S = this.points[0];\n    let E = this.points[this.order];\n    return Bezier.getABC(this.order, S, B, E, t);\n  }\n\n  getLUT(steps) {\n    this.verify();\n    steps = steps || 100;\n\n    if (this._lut.length === steps) {\n      return this._lut;\n    }\n\n    this._lut = []; // We want a range from 0 to 1 inclusive, so\n    // we decrement and then use <= rather than <:\n\n    steps--;\n\n    for (let i = 0, p, t; i < steps; i++) {\n      t = i / (steps - 1);\n      p = this.compute(t);\n      p.t = t;\n\n      this._lut.push(p);\n    }\n\n    return this._lut;\n  }\n\n  on(point, error) {\n    error = error || 5;\n    const lut = this.getLUT(),\n          hits = [];\n\n    for (let i = 0, c, t = 0; i < lut.length; i++) {\n      c = lut[i];\n\n      if (utils.dist(c, point) < error) {\n        hits.push(c);\n        t += i / lut.length;\n      }\n    }\n\n    if (!hits.length) return false;\n    return t /= hits.length;\n  }\n\n  project(point) {\n    // step 1: coarse check\n    const LUT = this.getLUT(),\n          l = LUT.length - 1,\n          closest = utils.closest(LUT, point),\n          mpos = closest.mpos,\n          t1 = (mpos - 1) / l,\n          t2 = (mpos + 1) / l,\n          step = 0.1 / l; // step 2: fine check\n\n    let mdist = closest.mdist,\n        t = t1,\n        ft = t,\n        p;\n    mdist += 1;\n\n    for (let d; t < t2 + step; t += step) {\n      p = this.compute(t);\n      d = utils.dist(point, p);\n\n      if (d < mdist) {\n        mdist = d;\n        ft = t;\n      }\n    }\n\n    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;\n    p = this.compute(ft);\n    p.t = ft;\n    p.d = mdist;\n    return p;\n  }\n\n  get(t) {\n    return this.compute(t);\n  }\n\n  point(idx) {\n    return this.points[idx];\n  }\n\n  compute(t) {\n    if (this.ratios) {\n      return utils.computeWithRatios(t, this.points, this.ratios, this._3d);\n    }\n\n    return utils.compute(t, this.points, this._3d, this.ratios);\n  }\n\n  raise() {\n    const p = this.points,\n          np = [p[0]],\n          k = p.length;\n\n    for (let i = 1, pi, pim; i < k; i++) {\n      pi = p[i];\n      pim = p[i - 1];\n      np[i] = {\n        x: (k - i) / k * pi.x + i / k * pim.x,\n        y: (k - i) / k * pi.y + i / k * pim.y\n      };\n    }\n\n    np[k] = p[k - 1];\n    return new Bezier(np);\n  }\n\n  derivative(t) {\n    return utils.compute(t, this.dpoints[0]);\n  }\n\n  dderivative(t) {\n    return utils.compute(t, this.dpoints[1]);\n  }\n\n  align() {\n    let p = this.points;\n    return new Bezier(utils.align(p, {\n      p1: p[0],\n      p2: p[p.length - 1]\n    }));\n  }\n\n  curvature(t) {\n    return utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);\n  }\n\n  inflections() {\n    return utils.inflections(this.points);\n  }\n\n  normal(t) {\n    return this._3d ? this.__normal3(t) : this.__normal2(t);\n  }\n\n  __normal2(t) {\n    const d = this.derivative(t);\n    const q = sqrt$1(d.x * d.x + d.y * d.y);\n    return {\n      x: -d.y / q,\n      y: d.x / q\n    };\n  }\n\n  __normal3(t) {\n    // see http://stackoverflow.com/questions/25453159\n    const r1 = this.derivative(t),\n          r2 = this.derivative(t + 0.01),\n          q1 = sqrt$1(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\n          q2 = sqrt$1(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n    r1.x /= q1;\n    r1.y /= q1;\n    r1.z /= q1;\n    r2.x /= q2;\n    r2.y /= q2;\n    r2.z /= q2; // cross product\n\n    const c = {\n      x: r2.y * r1.z - r2.z * r1.y,\n      y: r2.z * r1.x - r2.x * r1.z,\n      z: r2.x * r1.y - r2.y * r1.x\n    };\n    const m = sqrt$1(c.x * c.x + c.y * c.y + c.z * c.z);\n    c.x /= m;\n    c.y /= m;\n    c.z /= m; // rotation matrix\n\n    const R = [c.x * c.x, c.x * c.y - c.z, c.x * c.z + c.y, c.x * c.y + c.z, c.y * c.y, c.y * c.z - c.x, c.x * c.z - c.y, c.y * c.z + c.x, c.z * c.z]; // normal vector:\n\n    const n = {\n      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z\n    };\n    return n;\n  }\n\n  hull(t) {\n    let p = this.points,\n        _p = [],\n        q = [],\n        idx = 0;\n    q[idx++] = p[0];\n    q[idx++] = p[1];\n    q[idx++] = p[2];\n\n    if (this.order === 3) {\n      q[idx++] = p[3];\n    } // we lerp between all points at each iteration, until we have 1 point left.\n\n\n    while (p.length > 1) {\n      _p = [];\n\n      for (let i = 0, pt, l = p.length - 1; i < l; i++) {\n        pt = utils.lerp(t, p[i], p[i + 1]);\n        q[idx++] = pt;\n\n        _p.push(pt);\n      }\n\n      p = _p;\n    }\n\n    return q;\n  }\n\n  split(t1, t2) {\n    // shortcuts\n    if (t1 === 0 && !!t2) {\n      return this.split(t2).left;\n    }\n\n    if (t2 === 1) {\n      return this.split(t1).right;\n    } // no shortcut: use \"de Casteljau\" iteration.\n\n\n    const q = this.hull(t1);\n    const result = {\n      left: this.order === 2 ? new Bezier([q[0], q[3], q[5]]) : new Bezier([q[0], q[4], q[7], q[9]]),\n      right: this.order === 2 ? new Bezier([q[5], q[4], q[2]]) : new Bezier([q[9], q[8], q[6], q[3]]),\n      span: q\n    }; // make sure we bind _t1/_t2 information!\n\n    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\n    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2); // if we have no t2, we're done\n\n    if (!t2) {\n      return result;\n    } // if we have a t2, split again:\n\n\n    t2 = utils.map(t2, t1, 1, 0, 1);\n    return result.right.split(t2).left;\n  }\n\n  extrema() {\n    const result = {};\n    let roots = [];\n    this.dims.forEach(function (dim) {\n      let mfn = function (v) {\n        return v[dim];\n      };\n\n      let p = this.dpoints[0].map(mfn);\n      result[dim] = utils.droots(p);\n\n      if (this.order === 3) {\n        p = this.dpoints[1].map(mfn);\n        result[dim] = result[dim].concat(utils.droots(p));\n      }\n\n      result[dim] = result[dim].filter(function (t) {\n        return t >= 0 && t <= 1;\n      });\n      roots = roots.concat(result[dim].sort(utils.numberSort));\n    }.bind(this));\n    result.values = roots.sort(utils.numberSort).filter(function (v, idx) {\n      return roots.indexOf(v) === idx;\n    });\n    return result;\n  }\n\n  bbox() {\n    const extrema = this.extrema(),\n          result = {};\n    this.dims.forEach(function (d) {\n      result[d] = utils.getminmax(this, d, extrema[d]);\n    }.bind(this));\n    return result;\n  }\n\n  overlaps(curve) {\n    const lbbox = this.bbox(),\n          tbbox = curve.bbox();\n    return utils.bboxoverlap(lbbox, tbbox);\n  }\n\n  offset(t, d) {\n    if (typeof d !== \"undefined\") {\n      const c = this.get(t),\n            n = this.normal(t);\n      const ret = {\n        c: c,\n        n: n,\n        x: c.x + n.x * d,\n        y: c.y + n.y * d\n      };\n\n      if (this._3d) {\n        ret.z = c.z + n.z * d;\n      }\n\n      return ret;\n    }\n\n    if (this._linear) {\n      const nv = this.normal(0),\n            coords = this.points.map(function (p) {\n        const ret = {\n          x: p.x + t * nv.x,\n          y: p.y + t * nv.y\n        };\n\n        if (p.z && nv.z) {\n          ret.z = p.z + t * nv.z;\n        }\n\n        return ret;\n      });\n      return [new Bezier(coords)];\n    }\n\n    return this.reduce().map(function (s) {\n      if (s._linear) {\n        return s.offset(t)[0];\n      }\n\n      return s.scale(t);\n    });\n  }\n\n  simple() {\n    if (this.order === 3) {\n      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\n      const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\n      if (a1 > 0 && a2 < 0 || a1 < 0 && a2 > 0) return false;\n    }\n\n    const n1 = this.normal(0);\n    const n2 = this.normal(1);\n    let s = n1.x * n2.x + n1.y * n2.y;\n\n    if (this._3d) {\n      s += n1.z * n2.z;\n    }\n\n    return abs$1(acos$1(s)) < pi$1 / 3;\n  }\n\n  reduce() {\n    // TODO: examine these var types in more detail...\n    let i,\n        t1 = 0,\n        t2 = 0,\n        step = 0.01,\n        segment,\n        pass1 = [],\n        pass2 = []; // first pass: split on extrema\n\n    let extrema = this.extrema().values;\n\n    if (extrema.indexOf(0) === -1) {\n      extrema = [0].concat(extrema);\n    }\n\n    if (extrema.indexOf(1) === -1) {\n      extrema.push(1);\n    }\n\n    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n      t2 = extrema[i];\n      segment = this.split(t1, t2);\n      segment._t1 = t1;\n      segment._t2 = t2;\n      pass1.push(segment);\n      t1 = t2;\n    } // second pass: further reduce these segments to simple segments\n\n\n    pass1.forEach(function (p1) {\n      t1 = 0;\n      t2 = 0;\n\n      while (t2 <= 1) {\n        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n          segment = p1.split(t1, t2);\n\n          if (!segment.simple()) {\n            t2 -= step;\n\n            if (abs$1(t1 - t2) < step) {\n              // we can never form a reduction\n              return [];\n            }\n\n            segment = p1.split(t1, t2);\n            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n            segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\n            pass2.push(segment);\n            t1 = t2;\n            break;\n          }\n        }\n      }\n\n      if (t1 < 1) {\n        segment = p1.split(t1, 1);\n        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n        segment._t2 = p1._t2;\n        pass2.push(segment);\n      }\n    });\n    return pass2;\n  }\n\n  scale(d) {\n    const order = this.order;\n    let distanceFn = false;\n\n    if (typeof d === \"function\") {\n      distanceFn = d;\n    }\n\n    if (distanceFn && order === 2) {\n      return this.raise().scale(distanceFn);\n    } // TODO: add special handling for degenerate (=linear) curves.\n\n\n    const clockwise = this.clockwise;\n    const r1 = distanceFn ? distanceFn(0) : d;\n    const r2 = distanceFn ? distanceFn(1) : d;\n    const v = [this.offset(0, 10), this.offset(1, 10)];\n    const points = this.points;\n    const np = [];\n    const o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\n\n    if (!o) {\n      throw new Error(\"cannot scale this curve. Try reducing it first.\");\n    } // move all points by distance 'd' wrt the origin 'o'\n    // move end points by fixed distance along normal.\n\n\n    [0, 1].forEach(function (t) {\n      const p = np[t * order] = utils.copy(points[t * order]);\n      p.x += (t ? r2 : r1) * v[t].n.x;\n      p.y += (t ? r2 : r1) * v[t].n.y;\n    });\n\n    if (!distanceFn) {\n      // move control points to lie on the intersection of the offset\n      // derivative vector, and the origin-through-control vector\n      [0, 1].forEach(t => {\n        if (order === 2 && !!t) return;\n        const p = np[t * order];\n        const d = this.derivative(t);\n        const p2 = {\n          x: p.x + d.x,\n          y: p.y + d.y\n        };\n        np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);\n      });\n      return new Bezier(np);\n    } // move control points by \"however much necessary to\n    // ensure the correct tangent to endpoint\".\n\n\n    [0, 1].forEach(function (t) {\n      if (order === 2 && !!t) return;\n      var p = points[t + 1];\n      var ov = {\n        x: p.x - o.x,\n        y: p.y - o.y\n      };\n      var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n      if (distanceFn && !clockwise) rc = -rc;\n      var m = sqrt$1(ov.x * ov.x + ov.y * ov.y);\n      ov.x /= m;\n      ov.y /= m;\n      np[t + 1] = {\n        x: p.x + rc * ov.x,\n        y: p.y + rc * ov.y\n      };\n    });\n    return new Bezier(np);\n  }\n\n  outline(d1, d2, d3, d4) {\n    d2 = typeof d2 === \"undefined\" ? d1 : d2;\n    const reduced = this.reduce(),\n          len = reduced.length,\n          fcurves = [];\n    let bcurves = [],\n        p,\n        alen = 0,\n        tlen = this.length();\n    const graduated = typeof d3 !== \"undefined\" && typeof d4 !== \"undefined\";\n\n    function linearDistanceFunction(s, e, tlen, alen, slen) {\n      return function (v) {\n        const f1 = alen / tlen,\n              f2 = (alen + slen) / tlen,\n              d = e - s;\n        return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n      };\n    } // form curve oulines\n\n\n    reduced.forEach(function (segment) {\n      const slen = segment.length();\n\n      if (graduated) {\n        fcurves.push(segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen)));\n        bcurves.push(segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen)));\n      } else {\n        fcurves.push(segment.scale(d1));\n        bcurves.push(segment.scale(-d2));\n      }\n\n      alen += slen;\n    }); // reverse the \"return\" outline\n\n    bcurves = bcurves.map(function (s) {\n      p = s.points;\n\n      if (p[3]) {\n        s.points = [p[3], p[2], p[1], p[0]];\n      } else {\n        s.points = [p[2], p[1], p[0]];\n      }\n\n      return s;\n    }).reverse(); // form the endcaps as lines\n\n    const fs = fcurves[0].points[0],\n          fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\n          bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\n          be = bcurves[0].points[0],\n          ls = utils.makeline(bs, fs),\n          le = utils.makeline(fe, be),\n          segments = [ls].concat(fcurves).concat([le]).concat(bcurves);\n    return new PolyBezier(segments);\n  }\n\n  outlineshapes(d1, d2, curveIntersectionThreshold) {\n    d2 = d2 || d1;\n    const outline = this.outline(d1, d2).curves;\n    const shapes = [];\n\n    for (let i = 1, len = outline.length; i < len / 2; i++) {\n      const shape = utils.makeshape(outline[i], outline[len - i], curveIntersectionThreshold);\n      shape.startcap.virtual = i > 1;\n      shape.endcap.virtual = i < len / 2 - 1;\n      shapes.push(shape);\n    }\n\n    return shapes;\n  }\n\n  intersects(curve, curveIntersectionThreshold) {\n    if (!curve) return this.selfintersects(curveIntersectionThreshold);\n\n    if (curve.p1 && curve.p2) {\n      return this.lineIntersects(curve);\n    }\n\n    if (curve instanceof Bezier) {\n      curve = curve.reduce();\n    }\n\n    return this.curveintersects(this.reduce(), curve, curveIntersectionThreshold);\n  }\n\n  lineIntersects(line) {\n    const mx = min(line.p1.x, line.p2.x),\n          my = min(line.p1.y, line.p2.y),\n          MX = max(line.p1.x, line.p2.x),\n          MY = max(line.p1.y, line.p2.y);\n    return utils.roots(this.points, line).filter(t => {\n      var p = this.get(t);\n      return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\n    });\n  }\n\n  selfintersects(curveIntersectionThreshold) {\n    // \"simple\" curves cannot intersect with their direct\n    // neighbour, so for each segment X we check whether\n    // it intersects [0:x-2][x+2:last].\n    const reduced = this.reduce(),\n          len = reduced.length - 2,\n          results = [];\n\n    for (let i = 0, result, left, right; i < len; i++) {\n      left = reduced.slice(i, i + 1);\n      right = reduced.slice(i + 2);\n      result = this.curveintersects(left, right, curveIntersectionThreshold);\n      results.push(...result);\n    }\n\n    return results;\n  }\n\n  curveintersects(c1, c2, curveIntersectionThreshold) {\n    const pairs = []; // step 1: pair off any overlapping segments\n\n    c1.forEach(function (l) {\n      c2.forEach(function (r) {\n        if (l.overlaps(r)) {\n          pairs.push({\n            left: l,\n            right: r\n          });\n        }\n      });\n    }); // step 2: for each pairing, run through the convergence algorithm.\n\n    let intersections = [];\n    pairs.forEach(function (pair) {\n      const result = utils.pairiteration(pair.left, pair.right, curveIntersectionThreshold);\n\n      if (result.length > 0) {\n        intersections = intersections.concat(result);\n      }\n    });\n    return intersections;\n  }\n\n  arcs(errorThreshold) {\n    errorThreshold = errorThreshold || 0.5;\n    return this._iterate(errorThreshold, []);\n  }\n\n  _error(pc, np1, s, e) {\n    const q = (e - s) / 4,\n          c1 = this.get(s + q),\n          c2 = this.get(e - q),\n          ref = utils.dist(pc, np1),\n          d1 = utils.dist(pc, c1),\n          d2 = utils.dist(pc, c2);\n    return abs$1(d1 - ref) + abs$1(d2 - ref);\n  }\n\n  _iterate(errorThreshold, circles) {\n    let t_s = 0,\n        t_e = 1,\n        safety; // we do a binary search to find the \"good `t` closest to no-longer-good\"\n\n    do {\n      safety = 0; // step 1: start with the maximum possible arc\n\n      t_e = 1; // points:\n\n      let np1 = this.get(t_s),\n          np2,\n          np3,\n          arc,\n          prev_arc; // booleans:\n\n      let curr_good = false,\n          prev_good = false,\n          done; // numbers:\n\n      let t_m = t_e,\n          prev_e = 1; // step 2: find the best possible arc\n\n      do {\n        prev_good = curr_good;\n        prev_arc = arc;\n        t_m = (t_s + t_e) / 2;\n        np2 = this.get(t_m);\n        np3 = this.get(t_e);\n        arc = utils.getccenter(np1, np2, np3); //also save the t values\n\n        arc.interval = {\n          start: t_s,\n          end: t_e\n        };\n\n        let error = this._error(arc, np1, t_s, t_e);\n\n        curr_good = error <= errorThreshold;\n        done = prev_good && !curr_good;\n        if (!done) prev_e = t_e; // this arc is fine: we can move 'e' up to see if we can find a wider arc\n\n        if (curr_good) {\n          // if e is already at max, then we're done for this arc.\n          if (t_e >= 1) {\n            // make sure we cap at t=1\n            arc.interval.end = prev_e = 1;\n            prev_arc = arc; // if we capped the arc segment to t=1 we also need to make sure that\n            // the arc's end angle is correct with respect to the bezier end point.\n\n            if (t_e > 1) {\n              let d = {\n                x: arc.x + arc.r * cos$1(arc.e),\n                y: arc.y + arc.r * sin$1(arc.e)\n              };\n              arc.e += utils.angle({\n                x: arc.x,\n                y: arc.y\n              }, d, this.get(1));\n            }\n\n            break;\n          } // if not, move it up by half the iteration distance\n\n\n          t_e = t_e + (t_e - t_s) / 2;\n        } else {\n          // this is a bad arc: we need to move 'e' down to find a good arc\n          t_e = t_m;\n        }\n      } while (!done && safety++ < 100);\n\n      if (safety >= 100) {\n        break;\n      } // console.log(\"L835: [F] arc found\", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n\n      prev_arc = prev_arc ? prev_arc : arc;\n      circles.push(prev_arc);\n      t_s = prev_e;\n    } while (t_e < 1);\n\n    return circles;\n  }\n\n}\n\nexports.Bezier = Bezier;\n"]},"metadata":{},"sourceType":"script"}